;//	SMLOOK.SR
;//	EOF TEST, LOOKUP UP, CREATING, DELETING, RENAMING FILES

	.TITL	SMLOOK

	.GETNOLIST	"SMALL.OPS"
	.GETNOLIST	"SMALL.SYMS"
	.GETNOLIST	"SMFILES.OPS"
	.GETNOLIST	"SMFILES.SYMS"

	.SREL

EOF:	EOFC
LOOKP:	LOOKC
ENTER:	ENTERC
DELETE:	DELETC
ELOOK:	ELOOKC
RENAM:	RENAMC
FCLAS:	0	;// FILE CLASS ID

	.NREL

;//	TEST FOR FILE EOF
;//	 RETURNS+1 IF ON LAST PAGE AND BYTEC EXCEEDS NUMCH
;//	 RETURNS+2 IF EOF HAS NOT OCCURRED
;//	SMLOOK.SR

EOFC:	STA	3,EOF3	;// AC2 IS FILE INSTANCE TO CHECK FOR EOF
	JSR	@.LNST
	NEXTP
	SZE	0,0	;// NEXTP=0? (END OF FILE PAGE CHAIN)
	 JMP	EOFNO	;// IF BYTEC IS LARGE, ONLY WAY TO TEST
	JSR	@.LNST	;// EOF IS BY READING
	BYTEC
	STA	0,BC	;// SAVE
	JSR	@.LNST
	NUMCH
	LDA	1,BC
	SLT	1,0	;// BYTEC < NUMCH?
	 JMP	@EOF3	;// EOF
EOFNO:	LDA	3,EOF3
	JMP	1,3
 
.GBDK:	GBDSK
EOF3:	0
SYSLDR:	10000	;// PAGE 0 ADDRESS OF SYSTEM DIRECTORY -- 'SYSDIR.'
BC:	0
C12:	12
.GFCH:	GFCH
.DSKAD:	DSKADR
FIND:	0
CH:	0
COUNT:	0
;
;	/* SKIP IF CHARS IN AC0,1 ARE EQUAL
;	NO DISCRIMINATION FOR RACE, COLOR, OR UPPER/LOWER CASE
SKECH:	SNE	0,1	;// SAME CHAR?
	 JMP	1,3	;//	YEP
	STA	3,SKEX
	LDA	3,UPLOW	;//	NO, FLIP UPPER/LOWER CASE
	AND#	3,0,SNR
	 ADD	3,0,SKP
	SUB	3,0
	SNE	0,1	;// SAME CHAR(EXCEPT CASE)?
	 ISZ	SKEX
	JMP	@SKEX
UPLOW:	040	;THIS BIT DIFFERS FROM UPPER CASE TO LOWER
SKEX:	0
 
;//	DIRECTORY ENTRY FORMAT
;//	WORD (BITS)
;//	1	0-5	TYPE (0 DELETED, 1 NORMAL)
;//		6-15	LENGTH OF ENTRY IN WORDS (=N)
;//	2		SN1
;//	3		SN2
;//	4		VERSION NUMBER
;//	5		FILE NUMBER (??)
;//	6		LEADER PAGE VIRTUAL DISK ADDRESS
;//	7	0-7	LENGTH OF FILE NAME
;//		8-15	FIRST CHARACTER
;//	.
;//	.
;//	N	8-15	LAST CHAR (OR NULL IF EVEN LENGTH)

 
;//	LOOKUP AN OLD FILE IN SYSTEM DIRECTORY	 LOOKP
;//	 AC1=0 INITS FILE IF FOUND, AC1=1 JUST RETURNS
;//	RETURNS+1 IF ILLEGAL FILE NAME (NOT STRING OR TOO LONG)
;//	RETURNS+2 IF NOT FOUND
;//	RETURNS+3 IF FOUND
 
LOOKC:	STA	3,L3
	STA	2,FINST
	STA	1,FIND	;// WHAT TO DO IF FILE FOUND
	JSRII	.GBDK	;// GET BITTABLE INSTANCE, DISK NUMBER
	STA	2,BINST
	LDAF	CLAS	;// GET TYPE FOR FILE CLASS
	STA	0,@.FCLAS
	LDA	2,FINST
	INC	2,1	;// DIRECTORY INSTANCE FOR FILE --
	LOAD		;// FILE[DIRINST]
	STA	0,BC	;// SAVE

	LDA	1,C3
	ADD	0,1	;// FILE INSTANCE FOR DIRECTORY --
	LOAD		;// FILE[DIRINST[FILINST]]
	JSR	@.ISIT	;// IS IT A FILE?
.FCLAS:	FCLAS		;// FILE CLASS
	 SKIP		;// LOOKUP OF SYSTEM OR USER DIRECTORY
	JMP	DFOUND

	LDA	2,BC	;// GO TO NEXT HIGHER DIRECTORY
	INC	2,1	;// DIRECTORY INSTANCE FOR DIRECTORY --
	LOAD		;// FILE[DIRINST[DIRINST]]
	JSR	@.ISIT
	NCLAS
	 JMP	UDIR	;// USER DIRECTORY...
	SUBZR	1,1	;// ... SYSTEM DIRECTORY
	STA	1,SN1+LT
	ZER	1,1
	STA	1,SN2+LT
	LDA	1,SYSLDR	;// SYSTEM DIRECTORY ADR
	JMP	LINIT

UDIR:	LDA	1,C3	;// LOOKING UP A USER DIRECTORY
	ADD	0,1	;// FILE INSTANCE OF HIGHER DIR --
	LOAD		;// FILE[DIRINST[DIRINST[FILINST]]]
DFOUND:	STA	0,DFINST

	LDA	2,FINST	;// GET FILE NAME INSTANCE
	INC	2,1
	INC	1,1
	LOAD
	JSR	@.ISIT	;// IS IT A STRING?
	SCLAS
	 JMP	@L3	;// NO
	STA	0,LSTR
	INC	0,1	;// GET STRING LENGTH (SKIP TYPE)
	LOAD
;//	LDA	1,RBMSK	;// IS IT <='377 IN LENGTH? (ASSUME
;//	SLE	0,1	;// ALREADY CHECKED IN SMALLTALK).
;//	 JMP	@L3	;// TOO LONG!
	STA	0,NLEN	;// NAME LENGTH
	LDA	1,C4016	;// CHARS FOR 7 HEADER AND STRING WORDS
	ADDZR	1,0	;// (FILETYPE+NLEN+16)/2
	STA	0,EWD	;// EXPECTED ENTRY HEADER WORD
	LDA	2,DFINST
	JSRII	.SREW	;// REWIND DIRECTORY (TO PAGE 1)
	 JMP	@L3
 
NEXE:	JSR	EOFC	;// EOF WITHOUT FINDING FILE NAME?
	 JMP	ER2
	JSRII	.GFWD	;// READ A DIRECTORY ENTRY
	LDA	1,EWD	;// EXPECTED ENTRY WORD
	SEQ	0,1
	 JMP	SKENT	;// WRONG SIZE
	LDA	1,C12	;// SKIP NEXT 5 WORDS (SN1,SN2,VN,FN,VA)
	JSRII	.RFPTR
 
	JSRII	.GFCH	;// LENGTH OF BCPL STRING IS FIRST CHARACTER
	LDA	1,NLEN
	SEQ	0,1	;// COULD BE OFF BY ONE CHAR
	 JMP	SKAN	;// SKIP ALL OF NAME
	STA	0,COUNT
	ZER	0,0
	STA	0,LBC
 
LCH:	JSR	@.GNB	;// CHAR FROM STRING NAME
LBC:	0
LSTR:	0
	STA	0,CH
	JSRII	.GFCH	;// CHAR FROM NAME IN DIRECTORY
	LDA	1,CH
	JSR	SKECH	;// CHARS EQUAL?
	 JMP	SKRN	;// NO, SKIP REST OF NAME
	DSZ	COUNT
	 JMP	LCH

	LDA	0,NLEN	;// BACKUP TO PICK UP RELEVANT INFO
	LDA	1,C12
	ADD	0,1	;// NAME LENGTH + 5 WORDS
	COM	1,1	;// -AC1-1 (FOR NAME LENGTH CHAR)
	JSRII	.RFPTR
	JSRII	.GFWD
	STA	0,SN1+LT
	JSRII	.GFWD
	STA	0,SN2+LT
	LDA	1,C4	;// ASSUME VERSION=1, SKIP FN
	JSRII	.RFPTR
	JSRII	.GFWD
	MOV	0,1
	JSRII	.DSKAD	;// CONVERT VIRTUAL ADR TO DISK ADR
	 JMP	@L3	;// ILLEGAL ADR
LINIT:	STA	1,LEADER+LT

	DSZ	FIND	;// INITIALIZE INSTANCE?
	 JMP 	LRET	;// NO
	LDA	2,FINST	;// COPY INTEGERS TO INSTANCE
	JSRII	.RICOP
	SN2		;// START IN INSTANCE
	1+SN2+LT-.	;// START IN MEMORY
	-IMAX		;// HOW MANY
	JSRII	.SREW	;// (RE)WIND TO PAGE 1
	 NOP		;// COULD BE EOF OR ...?
LRET:	ISZ	L3	;// SUCCESS
ER2:	LDA	3,L3	;// OR ERROR
	JMP	1,3
 
SKRN:	LDA	1,NLEN	;// SKIP REST OF NAME
	LDA	0,COUNT	;// COUNT IS 1 MORE THAN CHARS LEFT SO
	ONE	3,3	;// WE SHOULD SUBTRACT 1, BUT NEED TO ADD 1
	SEV	1,1	;// IF THERE'S A NULL (NAME LENGTH IS EVEN)
	 SUB	3,0	;// SO...SUBTRACT ONE IF ODD
	JMP	SKCH
 
SKAN:	SOD	0,0	;// SKIP ALL OF NAME
	 INC	0,0	;// SKIP NULL IF EVEN NUMBER OF CHARS
	JMP	SKCH
SKENT:	LDA	3,C1777	;// SKIP ENTRY. MASK OFF TYPE, IF ANY
	AND	3,0	;// LENGTH OF ENTRY IN WORDS IN AC0
	NEG	0,0
	COMZL	0,0,SZC	;// (ENTRYSIZE-1)*2 I.E. NUM OF CHARS >= 0?
	 JMP	NEXE	;// 0 IF - (SHOULDN'T HAPPEN) SO CONTINUE
SKCH:	MOV	0,1,SZR	;// DON'T BOTHER IF ZERO CHARS
	 JSRII	.RFPTR	;// AC1 IS NUM OF CHARS TO SKIP
	JMP	NEXE	;// GO READ NEXT ENTRY
 
;//	  INSTANCE INITIALIZATION FOR OLD FILE(*'D VALUES IMPORTANT)

L3:	0

LTAB:	0	;// LEADER (SET IN LOOKP) *
FINST:	0
.RICOP:	RICOP
	0	;// DIRTY *
BINST:	0
.SREW:	SREW
.GFWD:	GFWD
DFINST:	0
.RFPTR:	RFPTR
C4016:	4016	;// TO FORCE REWIND TO READ LEADER *
	1	;// VN *
	0	;// SN1 *
	0	;// SN2 *
C1777:	1777
NLEN:	0
EWD:	0

LT	= LTAB-IBEG	;// INCOMPLETE INSTANCE OFFSETTING

 
;//	CREATE A NEW FILE	 ENTER
;//	RETURNS+1 IF FILE ALREADY EXISTS OR BAD FILE NAME
;//	RETURNS+2 IF SUCCESSFUL
 
ELOOKC:	STA	3,E3	;// SUCCESSFUL LOOKUP OR THEN ENTER
	ZER	1,1
	STA	1,FTYPE	;// NOT A DIRECTORY IF ENTER OCCURS
	ONE	1,1	;// INIT INSTANCE IF FOUND
	JSRII	.LOOK
	 JMP	@E3	;// BAD NAME
	 JMP	ENT1	;// FILE NOT FOUND
	JMP	EDONE	;// FOUND

ENTERC:	STA	3,E3
	STA	1,FTYPE	;// 100000 (DIRECTORY) OR 0 (NORMAL)
	ZER	1,1	;// RETURN WITHOUT READING FILE IF FOUND
	JSRII	.LOOK
	 JMP	@E3	;// ILLEGAL NAME
	 SKIP		;// FILE NOT FOUND
	JMP	@E3	;// ALREADY EXISTS

ENT1:	LDA	0,LSTR	;// COPY FILE NAME POINTER
	STA	0,ESTR
	LDA	2,BINST	;// GET NEW FILE SERIAL NUMBER
	JSRII	.SREOF	;// POSITION TO EOF (WRITE IF DIRTY),
	LDA	1,M4	;// SHOULDN'T SKIP. BACKUP TWO WORDS.
	JSRII	.RFPTR
	JSRII	.GFWD
	STA	0,SN1+ET
	JSRII	.GFWD
	INC	0,0,SNR	;// OVERFLOW?
	 ISZ	SN1+ET
	STA	0,SN2+ET
	LDA	1,M4	;// REWRITE SN1,SN2 IN BITTABLE
	JSRII	.RFPTR
	LDA	0,SN1+ET
	LDA	1,FTYPE	;// ADD IN FILE TYPE
	ADD	0,1
	STA	1,SN1+ET	;// SO IT GOES INTO LABEL, NOT
	JSRII	.PFWD		;// INTO BITTABLE (I.E. AC0)
	LDA	0,SN2+ET
	JSRII	.PFWD

	ZER	1,1	;// FIRST FREE PAGE AFTER DISK ADR 0
	JSRII	.ALLOC	;// ALLOC LEADER PAGE AND RETURN DISK ADR
	 JMP	@E3	;// DISK FULL OR ILLEGAL ADR
	STA	1,CURADR+ET  
	STA	1,LEADER+ET

	LDA	2,FINST	;// COPY TABLE TO INSTANCE
	JSRII	.RICOP
	SN2		;// LEADER THROUGH SN2
	1+SN2+ET-.
	-IMAX
	ZER	0,0	;// POSITION TO BEG OF PAGE 1
	ONE	1,1
	JSRII	.SWBYT	;// WRITE LEADER, ALLOCATE NEXT PAGE
	 JMP	@E3

	LDA	2,BINST
	JSRII	.SREW	;// REWIND (AND WRITE) BITTABLE
	 JMP	@E3
	LDA	2,DFINST	;// FIND HOLE FOR DIRECTORY ENTRY
	JSRII	.SREOF		;// (JUST GO TO EOF), RECYCLE HOLES?
	JSR	PUTENT	;// PUT ENTRY IN
	LDA	2,FINST
	LDA	1,FTYPE
	SP	1,1	;// IF FILE IS A DIRECTORY, PUT
	 JSR	PUTENT	;// IN AN ENTRY TO ITSELF
EDONE:	LDA	3,E3
	JMP	1,3
 
PUTENT:	STA	3,L3
	LDA	0,EWD	;// LENGTH OF ENTRY + 2000
	JSRII	.PFWD	;// HEADER WORD
	LDA	0,SN1+ET
	JSRII	.PFWD	;// SN1
	LDA	0,SN2+ET
	JSRII	.PFWD
	ONE	0,0	;// VERSION NUMBER
	JSRII	.PFWD
	ZER	0,0
	JSRII	.PFWD	;// GENE'S FILE NUMBER
	LDA	1,LEADER+ET 
	JSRII	.DSKSC	;// CONVERT DISK ADR TO VIRTUAL ADR
	MOV	1,0	;// INTO AC0 FOR PFWD
	JSRII	.PFWD	;// DISK ADR OF PAGE 0
 
	LDA	0,NLEN	;// FILE NAME LENGTH FROM LOOKUP
	JSRII	.PFCH
	LDA	0,ESTR		;// FILE NAME
	JSRII	.PFSTR
	ZER	0,0
	LDA	1,NLEN
	SOD	1,1
	 JSRII	.PFCH	;// WRITE NULL IF EVEN LENGTH
	JSRII	.SREW	;// REWIND (AND WRITE) DIRECTORY
	 JMP	@E3
	JMP	@L3
 
;//	MARK A DIRECTORY ENTRY DELETED
;//	ASSUMES DIRECTORY IS POSITIONED AFTER VIRTUAL
;//	DISK ADDRESS WORD OF ENTRY

MARKD:	STA	3,L3
	LDA	1,M14	;// BACKUP 6 WORDS TO ENTRY HEADER WORD
	LDA	2,DFINST
	JSRII	.RFPTR
	LDA	0,EWD	;// FROM LOOKUP
	LDA	1,C1777
	AND	1,0	;// 0 FOR FILE TYPE
	JSRII	.PFWD	;// PUT WORD BACK INTO DIRECTORY
	JMP	@L3


;//	INSTANCE INITIALIZATION FOR NEW FILE (*'D VALUES IMPORTANT)

ETAB:	0	;// LEADER *
	0	;// CURADR *
E3:	0
M4:	-4	;// DIRTY * (SMFSET WILL WRITE LABEL)
FTYPE:	0
	0	;// NEXT PTR *
	0	;// BACK PTR *
	0	;// LABEL BLOCK WORD 3 (UNUSED) *
.LOOK:	LOOKP	;// (NUMCH _ '1000 IN SMFSET)
	0	;// PAGE NUMBER *
	1	;// VERSION NUMBER *
	0	;// SERIAL NUMBER 1 (&2) *
	0

ET	= ETAB-IBEG

;//	RENAME A FILE
;//	ASSUMES THAT LOOKUP HAS JUST OCCURRED AND THAT
;//	"FNAME" IS THE NEW FILE NAME
;//	 AC2 HAS FILE INSTANCE
;//	RETURNS+1 IF ERROR
;//	RETURNS+2 IF SUCCESSFUL

RENAMC:	STA	3,E3
	INC	2,1	;// AC2 HAS FILE INSTANCE
	INC	1,1
	LOAD
;//	JSR	@.ISIT
;//	SCLAS
;//	 JMP	@E3
	STA	0,ESTR	;// FOR PUTENT
	INC	0,1
	LOAD
	STA	0,NLEN	;// NEW NAME LENGTH
	JSR	MARKD	;// MARK ENTRY AS DELETED
	LDA	1,C4016
	LDA	0,NLEN
	ADDZR	1,0
	STA	0,EWD
	
	JSR	@.PNT
	LT-.
	MOV	0,3		;// ...+LT ALMOST WORKS
	LDA	0,LEADER,3
	STA	0,LEADER+ET	;// FOR PUTENT
	LDA	0,SN1,3
	STA	0,SN1+ET
	LDA	0,SN2,3
	STA	0,SN2+ET

	JSRII	.SREOF	;// PUT NEW ENTRY AT EOF (DIRECTORY IN AC2)
	JSR	PUTENT
	LDA	3,E3
	JMP	1,3

.SREOF:	SREOF
ESTR:	0
.PFWD:	PFWD
.ALLOC:	ALLOC
.SWBYT:	SWBYTE
.DSKSC:	DSKSEC
.PFCH:	PFCH
M14:	-14
.DALOC:	DALLOC
.SFLUS:	SFLUSH
.PFSTR:	PFSTR

;//	DELETE A FILE FROM A DIRECTORY
;//	 AC2 HAS FILE INSTANCE
;//	RETURNS+1 IF BAD NAME OR FILE NOT FOUND
;//	RETURNS+2 IF SUCCESSFUL

DELETC:	STA	3,E3	;// AC2 IS FILE INSTANCE TO DELETE
	ZER	1,1	;// DON'T INIT INSTANCE
	JSRII	.LOOK
	 JMP	@E3	;// BAD NAME
	 JMP	@E3	;// FILE NOT FOUND
	JSRII	.DALOC	;// DEALLOCATE PAGE CHAIN, AC1 HAS
	 JMP	@E3	;// LEADER PAGE ADDRESS

	JSR	MARKD	;// MARK DELETED IN DIRECTORY
	JSRII	.SFLUS	;// WRITE DIRECTORY (IN AC2)
	 JMP	@E3
	LDA	3,E3
	JMP	1,3

	.END
 
