;//	SMDSK.SR
;//	EXECUTE DISK COMMANDS

	.TITL	SMDSK

	.GETNOLIST	"SMALL.OPS"
	.GETNOLIST	"SMALL.SYMS"
	.GETNOLIST	"SMFILES.OPS"
	.GETNOLIST	"SMFILES.SYMS"

	.SREL

DSKIO:	DSKIOC
DSK0:	DSK0C
DSTART:	DSTRTC
DCHECK:	DCHEKC

	.NREL

;// THE STRATEGY FOR USING 3 LABEL BLOCKS (AND DCB'S) IS
;// THAT WHILE ONE IS BEING READ (CHECKED, OR WRITTEN),
;// THE NEXT (NDCB) IS BEING READIED, WHILE THE OTHER 
;// IS THE LAST ACCURATE LABEL (BACKUP IN CASE OF ERROR)
;// DCB1 IS USED FIRST, AC2 USUALLY POINTS TO CURRENT DCB

;//	DISK STATUS FORMAT
;//	BITS
;//	0-3	??? SECTOR
;//	4-7	DISK DONE = 17
;//	8	SEEK FAILED, ILLEGAL TRACK ADR
;//	9	SEEK IN PROGRESS
;//	10	NOT READY
;//	11	HARDWARE LATE (UNRELIABLE)--RETRY
;//	12	HARDWARE NOT XFERING (SHOULDN'T HAPPEN)
;//	13	CHECKSUM -- RETRY
;//	14	CHECK ERROR
;//	15	HARDW ERR, SECTOR OVERFLOW (14&15--ILLEGAL SECTOR)
 
	NDCB	=DCBH1+LABSIZ+1	;// NEXT DCB
.HEAD:	DCBH1
J3:	JSR	0,3	;// RETURN ADDRESS TO...
	JMP	0,3	;// DUMMY COROUTINE (IMMED RETURN)

DCB1A:	JSR	0,3	;// TRICK TO GET DCB1'S ADDRESS
DCB1:	0		;// NEXT DCB	-- DCBPTR
	0		;// STATUS		-- DCBSTAT
	0		;// COMMAND		-- DCBCOM
	0		;// HEADER PTR	-- DCBHEAD
	0		;// LEADER PTR	-- DCBLAB
	0		;// DATA PTR	-- DCBDAT
	0		;// INTERRUPT WORD 1 (NO ERROR) -- DCBI1
	0		;// INTERRUPT WORD 2 (ERROR)   -- DCBI2
	0		;// UNUSED		-- DCBH1
LL3:	.BLK	LABSIZ	;// ADDRESS [DCB1+DCBH2 = LL3+NEXTP-LABEG]
	0		;// NDCB

DCB2A:	JSR	0,3
DCB2:	.BLK	DCBH2
LL1:	.BLK	LABSIZ+1
DCB3A:	JSR	0,3
DCB3:	.BLK	DCBH2
LL2:	.BLK	LABSIZ+1

;//	AC0 STARTING CORE ADDRESS
;//	AC1 STARTING ALTO DISK ADDRESS
;//	AC2 DISK COMMAND (CRR, CRW, CCR, CCW, CWW)
;//	JSRII	.DSKIO/.DSK0
;//	RELATIVE PTR TO DISK # OR COROUTINE ADDRESS,
;//		 FOLLOWED BY 10 WORD LABEL BLOCK
;//	STARTING PAGE NUMBER (RELEVANT IF LABEL CHECKING ON)
;//	NUMBER OF PAGES TO TRANSFER (SHOULD BE 1 FOR CWW)
;//	CORE INCREMENT (USUALLY 0 OR 400)
;//	  ERROR RETURN
;//	NORMAL RETURN
;//	 AC0 IS NUMBER OF REMAINING PAGES
;//	 AC1 IS LAST DISK ADDRESS PROCESSED
;//	 AC2 PTR TO LAST DISK COMMAND BLOCK

;//	CALLING SEQUENCE FOR DSTART/DCHECK
;//	AC0, AC1, AC2 SAME AS DSKIO
;//	JSRII	.DSTART
;//	REL PTR...
;//	STARTING PAGE NUMBER...
;//	NORMAL RETURN
;//	<OTHER CODE>
;//	JSRII	.DCHECK
;//	  ERROR RETURN
;//	NORMAL RETURN

DSTRTC:	STA	1,DTRY	;// CHECK ZERO ADR?
	ONE	1,1
	STA	1,NUMPGS  ;// ONE PAGE ONLY, IMMEDIATE RETURN
	JMP	DDD

DSKIOC:	SNZ	1,1	;// ZERO DISK ADDRESS?
	 JMP	DARGS,3
DSK0C:	STA	1,DTRY	;// SAVE ADR SINCE LABEL OVERWRITES DCBH2
	LDA	1,2,3	;// NUMBER OF PAGES
	SGZ	1,1
	 JMP	DARGS,3	;// ERROR, PAGES=0
	STA	1,NUMPGS
	LDA	1,3,3	;// CORE INCREMENT
	STA	1,CORINC
	ZER	1,1	;// NO IMMEDIATE RETURN
DDD:	STA	1,ONCE
	STA	3,D3
	LDA	1,0,3	;// LABEL BLOCK OFFSET
	ADD	1,3	;// ADD PC
	STA	3,LPTR	;// PTR TO LABEL BLOCK - 1
	LDA	1,0,3	;// DISK NUMBER OR COROUTINE ADR
	JSR	J3	;// GET DEFAULT COROUTINE ADR
	SNZ	1,1
	 JMP	.+4	;// 0 DISK NUMBER
	MOVZR#	1,1,SNR	;// IF AC1 IS 1, THEN FIX COMMAND
	 INC	2,2,SKP	;// TO COMPLEMENT DISK # IN ADDRESS
	MOV	1,3	;// ANYTHING ELSE IS COROUTINE ADR
	STA	3,COROUT

	LDA	1,DCBHEAD+DCB1	
	SZE	1,1	;// ARE ABSOLUTE POINTERS SET (FIRSTIME)?
	 JMP	LABSET	;// YES
	LDA	1,.HEAD		;// HEADER IS LAST 2 WORDS OF DCB
	JSR	DCB1A		;// GET ADDRESS OF DCB1
	STA	3,NDCB+DCB3	;// USE DCB1 AFTER DCB3
	ADD	1,3
	STA	3,DCBHEAD+DCB1	;// PTR TO HEADER BLOCK
	INC	3,3
	STA	3,DCBLAB+DCB3	;// DCB3'S LABEL STARTS AT LAST
				;// WORD OF DCB1

	JSR	DCB2A
	STA	3,NDCB+DCB1
	ADD	1,3
	STA	3,DCBHEAD+DCB2
	INC	3,3
	STA	3,DCBLAB+DCB1

	JSR	DCB3A
	STA	3,NDCB+DCB2
	ADD	1,3
	STA	3,DCBHEAD+DCB3
	INC	3,3
	STA	3,DCBLAB+DCB2


LABSET:	LDA	1,@KBLK	;// WAIT UNTIL DISK IS FREE
	SZE	1,1	;// BEFORE ZAPPING ANY DCB'S OR LABEL'S
	 JMP	.-2		;// ORIGINAL AC0 AND AC2(ALMOST)
	STA	2,DCBCOM+DCB1	;// DISK COMMAND
	STA	2,DCBCOM+DCB2
	STA	2,DCBCOM+DCB3
	STA	0,DCBDAT+DCB1	;// CORE ADDRESS

	LDA	0,LPTR		;// COPY LABEL BLOCK(S)
	LDA	1,DCBLAB+DCB1	;// DEST (AC0 HAS SOURCE-1)
	LDA	3,MLABSZ	;// -COUNT
	ADC	3,1		;// DEST+COUNT-1
	BLT

	LDA	3,NUMPGS
	STA	3,TOTPGS	;// FOR ERROR CHECKER
	MOVZR#	3,3,SNR
	 JMP	DCBSET		;// <2 PAGES, SO DON'T BOTHER
	LDA	0,LPTR
	LDA	1,DCBLAB+DCB2
	LDA	3,MLABSZ
	ADC	3,1
	BLT
	LDA	0,LPTR
	LDA	1,DCBLAB+DCB3
	LDA	3,MLABSZ
	ADC	3,1
	BLT

DCBSET:	LDA	2,NDCB+DCB3		;// DCB1 IS USED FIRST
	ZER	0,0
	STA	0,@KINT		;// NO INTERRUPTS
	STA	0,DCBPTR,2	;// INITIALIZE FIRST DCB
	STA	0,DCBSTAT,2
	STA	0,DCBH1,2

	LDA	1,DTRY		;// SAVED ADDRESS...
	STA	1,DCBH2,2	;// INTO FIRST DCB
	LDA	1,DCBCOM,2	;// DISK COMMAND
	LDA	3,C40
	AND	1,3,SZR	;// FIX LABEL FOR CHECKING UNLESS WRITING
	 JMP	DNEXT
	STA	0,NEXTP-LABEG+LL1
	STA	0,BACKP-LABEG+LL1
	STA	0,NUMCH-LABEG+LL1
	STA	0,LNUSED-LABEG+LL1
	LDA	3,D3		;// GET STARTING PAGE NUMBER
	LDA	1,1,3		;// FOR LABEL FROM CALLER
	STA	1,PAGEN-LABEG+LL1
	JMP	DNEXT

TOTPGS:		.-.	;// TOTAL NUMBER OF PAGES REQUESTED
KINT:	524		;// DISK INTERRUPT MASK WORD
CORINC:	.-.
ONCE:	.-.		;// FLAG FOR IMMEDIATE RETURN
KBLK:	521		;// DISK CONTROLLER START ADR
DTRY:	.-.		;// ERROR RETRY COUNTER, ALSO TEMP
C40:	40		;// WRITE LABEL COMMAND BIT
LPTR:	.-.		;// USER 'LABEL BLOCK'
MLABSZ:	-LABSIZ		;// -SIZE OF LABEL BLOCK
NUMPGS:	.-.		;// PAGE COUNTER
D3:	.-.
COROUT:	.-.
		;// COROUTINE ADDRESS

DNEXT:	LDA	1,C4	;// TRY 4 (MORE?) TIMES BEFORE QUITTING
	STA	1,DTRY	;// ON DISK ERROR.
	LDA	3,@KBLK
	SNZ	3,3	;// DISK STILL RUNNING?
DREST:	 LDA	3,KBLK	;// NO, SO GIVE DCB DIRECTLY TO CONTROLLER
	STA	2,0,3	;// OR CHAIN TO RUNNING DCB(DEPTH 1)
	LDA	3,@KBLK	;// TIMING PROBLEM. MAKE SURE
	SNZ	3,3	;// CONTROLLER REALLY GOT IT.
	 JMP	DREST

	DSZ	ONCE	;// IMMEDIATE RETURN?
	 JMP	.+4	;// NO
	LDA	3,D3
	STA	2,D3	;// FOR DCHECK LATER...
	JMP	DARGS-2,3	;// 2 FEWER ARGS THAN DSKIO

	LDA	3,DCBLAB,2	;// CURRENT LABEL
	LDA	1,PAGEN-LABEG,3	;// CURRENT PAGE NUMBER(KEEP IN AC1)
	LDA	0,DCBDAT,2	;// CURRENT CORE ADDRESS
	LDA	3,CORINC
	ADD	3,0		;// NEW CORE ADDRESS
	LDA	3,NDCB,2		;// PREPARE NEXT DCB
	STA	0,DCBDAT,3
	ZER	0,0
	STA	0,DCBPTR,3
	STA	0,DCBSTAT,3
	STA	0,DCBH1,3

	LDA	3,DCBLAB,3	;// ...AND NEXT LABEL
	INC	1,1
	STA	1,PAGEN-LABEG,3	;// CHECK PAGE
	STA	0,NEXTP-LABEG,3
	STA	0,NUMCH-LABEG,3
	STA	0,LNUSED-LABEG,3
	LDA	0,DCBH2,2		;// CURRENT DISK ADR
	STA	0,BACKP-LABEG,3	;// CHECK BACKP

CKSTAT:	LDA	3,SBITS		;// STATUS BITS
	LDA	1,@DCBLAB,2	;// FIRST WORD OF LABEL, I.E. NEXTP
	LDA	0,DCBSTAT,2	;// CURRENT DCB STATUS
	AND	3,0,SNR		;// ERROR OR FINISHED?
	 JMP	NCHECK		;// NOTHING YET
	LDA	3,OKVAL
	SNE	0,3	;// ERROR BITS ON?
	 JMP	PDONE
	LDA	0,@KBLK	;// WAIT UNTIL CONTROLLER STOPS (RATHER
	SZE	0,0	;// THAN POSSIBLY CHAIN TO SELF)
	 JMP	.-2
	DSZ	DTRY	;// RETRY A FEW TIMES
	 JMP	DREST
	LDA	0,TOTPGS	;// ORIGINAL NUMBER OF PAGES
	LDA	1,NUMPGS	;// PAGES TO GO
	SNE	0,1	;// DID WE FINISH FIRST PAGE
	 JMP	ACRET	;// NO
	STA	2,DTRY	;// BAD DCB WAS THIS ONE
	LDA	2,NDCB,2	;// BUT RETURN LAST GOOD LABEL
	LDA	2,NDCB,2
	JMP	LRET

NCHECK:	LDA	0,DCBCOM,2	;// IF WRITING LABEL THEN
	LDA	3,C40	;// WAIT UNTIL STATUS COMES IN
	SZE	1,1	;// OTHERWISE, LABEL HAS STARTED CHECKING
	 AND	0,3,SZR	;// OR READING AND THINGS ARE PROBABLY OK
	  JMP	CKSTAT

PDONE:	JSR	@COROUT	;// CALL COROUTINE
	DSZ	NUMPGS	;// DON'T CONTINUE IF PAGES=0
	 SNZ	1,1	;// OR NEXTP=0 (EOF?)
	  JMP	SRET
	LDA	2,NDCB,2	;// SWITCH TO NEXT DCB
	JMP	DNEXT
SRET:	ISZ	D3	;// SUCCESSFUL RETURN
	STA	2,DTRY	;// GOOD DCB
LRET:	LDA	1,LPTR	;// RETURN LABEL BLOCK
	LDA	3,MLABSZ
	SUB	3,1	;// USER LABEL-1+COUNT
	LDA	0,DCBLAB,2
	NEG	0,0
	COM	0,0	;// LLX-1
	BLT
	LDA	0,NUMPGS	;// PAGES LEFT
	LDA	2,DTRY		;// RESTORE DCB PTR
ACRET:	LDA	1,DCBH2,2	;// LAST ADDRESS
	LDA	3,D3
	JMP	DARGS,3

DCHEKC:	LDA	2,D3	;// SAVED DCB PTR
	LDA	0,C4	;// I.E. DARGS
	SUB	0,3
	STA	3,D3	;// TO USE DSKIO'S RETURN
	JMP	CKSTAT
SBITS:	7667		;// FOR DISK STATUS CHECKING
OKVAL:	7400		;// GOOD DISK STATUS

	.END
R
