;//	SMFILES.SR
;//	COPY VIRTUAL MEMORY(STRINGS),INSTANCE INTEGERS,
;//	AND MEMORY. FILE READING/WRITING OF CHARACTERS,
;//	WORDS, AND STRINGS.

	.TITL	SMFILES

	.GETNOLIST	"SMALL.OPS"
	.GETNOLIST	"SMALL.SYMS"
	.GETNOLIST	"SMFILES.OPS"
	.GETNOLIST	"SMFILES.SYMS"

	.SREL

RICOP:	RICOPC
IRCOP:	IRCOPC
RFPTR:	RFPTRC
GFCH:	GFCHC
GFWD:	GFWDC
GFSTR:	GFSTRC
PFCH:	PFCHC
PFWD:	PFWDC
PFSTR:	PFSTRC
BLTT:	BLTC
DSKBUF:	0
SBCOP:	S2B
BSCOP:	B2S

	.NREL
-1

	VSAV	=6	;// SIZE OF SAVE AREA FOR SOME VARIABLES

;DSKBFA:	.BLK	400	;// BUFFER ALLOCATED IN PAGE1.SR
.DBUF:	DSKBUF

;	**STEVE - I CROCKED  S2B, B2S SO DSKBUF COULD BE MOVED.
;	FIGURED THEY'D GO AWAY WITH LOCK, UNLK ANYWAY... DAN
C400M4:	400-4	;400 GETS TO BUF END, -4 FOR (1+LOC[JSR])-LOC[.-.]

S2B:	STA	3,R3	;// STRING IN AC2 TO STANDARD BUFFER
	LDA	0,@.DBUF
	LDA	1,C400M4
	ADD	1,0
	JSR	.+1	;ADDRS CRITICAL THRU .+5 !!
	SUB	3,0	;THIS DOES '-.', THO OFF BY 4
	STA	0,.+3
	JSR	VRCOPC
	377
	.-.	;1+DSKBFA+377-.
	-400
	LDA	0,@.DBUF	;// RETURN THIS ADDRESS FOR DSKIO
	JMP	@R3

B2S:	STA	3,R3	;// BUFFER TO STRING IN AC2
	LDA	0,@.DBUF
	LDA	1,C400M4
	ADD	1,0
	JSR	.+1	;ADDRS CRITICAL THRU .+5 !!
	SUB	3,0	;THIS DOES '-.', THO OFF BY 4
	STA	0,.+3
	JSR	RVCOPC
	377
	.-.	;1+DSKBFA+377-.
	-400
	JMP	@R3


;//	COPY FROM/TO MEMORY TO/FROM INSTANCE INTEGERS OR VMEM
;//	 AC2 HAS INSTANCE PTR
;//	JSR --COP
;//	 LAST VIRTUAL ENTRY, OFFSET
;//	 LAST MEMORY WORD, OFFSET
;//	 NEGATIVE WORD COUNT
 
VRCOPC:	STA	3,COP3	;// VIRTUAL (STRINGS) TO MEMORY
	JSR	COPYC	;// GET PC AND SET UP POINTERS
	LOAD		;// LOAD VMEM WORD
	STA	0,@REAL	;// PUT IN MEMORY
	JMP	CNEXT

IRCOPC:	STA	3,COP3	;// INSTANCE INTEGERS TO MEMORY
	JSR	COPYC
	LOAD		;// INSTANCE INTEGER
	JSR	@.IVAL
	STA	0,@REAL
	JMP	CNEXT

RICOPC:	STA	3,COP3	;// MEMORY TO INSTANCE INTEGERS
	JSR	COPYC
	LDA	0,@REAL
	JSR	SNSTE	;// STORE NEW AND RECYCLE OLD INTEGER
	JMP	CNEXT

COPYC:	STA	2,AC2	;// SAVE
	STA	3,LOC	;// ADR OF WHERE TO GO FOR EACH COPY
	LDA	3,COP3
	LDA	1,0,3
	ADD	2,1	;// ADD VIRTUAL OFFSET
	STA	1,VIRT

	LDA	0,1,3
	ADD	3,0	;// ADD PC
	STA	0,REAL

	LDA	0,2,3
	STA	0,COUNT	;// ASSUME NEGATIVE AND NONZERO
	JMP	@LOC	;// FIRST TIME, AC1 STILL HAS VIRT

RVCOPC:	STA	3,COP3	;// MEMORY TO VIRTUAL
	JSR	COPYC
	LDA	0,@REAL	;// GET MEMORY WORD
	STOR		;// PUT IN VMEM

CNEXT:	DSZ	REAL
	DSZ	VIRT
	LDA	1,VIRT
	ISZ	COUNT
	 JMP	@LOC
	LDA	2,AC2	;// ORIGINAL VALUE
	LDA	3,COP3
	JMP	3,3

REAL:	0
COP3:	0
LOC:	0
COUNT:	0
VIRT:	0
 
;//	RELATIVE REPOSITION FILE POINTER	 RFPTRC
;//	 AC1 CONTAINS OFFSET
;//	 AC2 CONTAINS INSTANCE
 
RFPTRC:	STA	3,R3
	STA	0,LOC	;// SAVE AC0
	STA	1,COUNT	;//OFFSET
	JSR	@.LNST	;// LNST USES BUT PRESERVES AC2
	BYTEC
	LDA	1,COUNT
	ADD	1,0	;// CURRENT BYTEC IN AC0
RFSET:	JSR	@.SNST
	BYTEC
RFRET:	LDA	0,LOC	;// RESTORE
	JMP	@R3

R3:	0
AC2:	0
LIRET:	0
T1:	0
SITMP:	0
 
;//	LIKE "SINST" EXCEPT FOR INSTANCE IN AC2
 
;// SNSTC:	STA	2,AC2
;// 	LDA	1,0,3
;// 	ADD	2,1
;// 	INC	3,3
SNSTE:	STA	1,T1	;// ENTRY PT WITH AC1 ALREADY SET, NO SKIP
	STA	3,LIRET
	JSR	@.INTN
	STA	0,SITMP
	LDA	1,T1
	LOAD
;//	LDA	1,T1	;// AC1 PRESERVED
	STA	0,T1
	LDA	0,SITMP
	STOR
	LDA	0,T1
	JSR	@.REFD
	LDA	2,AC2	;// RESTORE
	JMP	@LIRET
 
EVPTR:	STA	3,R3	;// INCREMENT BYTE PTR IF ODD
	STA	0,LOC
	JSR	@.LNST
	BYTEC
	SOD	0,0
	 JMP	RFRET	;// RESTORE AC0 AND RETURN
	INC	0,0
	JMP	RFSET

;//	GET A CHARACTER FROM A FILE	 GFCHC
;//	 AC2 CONTAINS FILE INSTANCE
;//	RETURNS+1, AC0 IS CHARACTER
 
GFCHC:	STA	3,G3
;//	STA	2,FINST	;// SAVE FILE INSTANCE
	LDA	1,C3	;// ESTABLISH STRING ADR AND BYTE COUNT
	ADD	2,1
	LOAD
	STA	0,GSTR	;// STRING INSTANCE
;//	LDA	2,FINST
	JSR	@.LNST
	BYTEC
	SP	0,0	;// BC >= 0?
	 JMP	GPAG
	STA	0,GBC
	SKIP
GFCHC1:	 STA	3,G3	;// ENTRY PT FOR GETTING BYTE FROM SAME FILE
	JSR	@.LNST
	NUMCH
	LDA	1,GBC
	SGE	1,0	;// BC >= NUMCH?
	 JMP	GCH
	MOV	1,0	;// BC
GPAG:	NIL	1,1	;// THIS PAGE
	JSRII	.SRBYT
	 JMP	@G3	;// EOF OR ERROR. ZERO BYTE RETURNED
	STA	1,GBC
GCH:	INC	1,0	;// NEW BYTE COUNT FOR INSTANCE
	JSR	@.SNST
	BYTEC
	JSR	@.GNB	;// GET NEXT BYTE FROM SMALLTALK STRING
GBC:	0
GSTR:	0
	JMP	@G3	;// AC0 CONTAINS CHARACTER
 
;//	GET A WORD FROM A FILE	 GFWDC
 
GFWDC:	STA	3,GW3
	JSR	EVPTR	;// IF NOT WORD BOUNDARY THEN SKIP CHAR
	JSR	GFCHC	;// GET FIRST CHAR
	MOVS	0,0	;// SWAP HALVES
	STA	0,LHALF	;// AND SAVE
	JSR	GFCHC1	;// GET NEXT BYTE AT ENTRY POINT
	LDA	1,LHALF
	ADD	1,0	;// COMBINE TWO BYTES INTO A WORD
	JMP	@GW3
 
;//	GET A STRING FROM A FILE	GFSTRC
;//	 AC0 IS STRING INSTANCE (TO WRITE INTO)
;//	 AC2 IS FILE INSTANCE
 
GFSTRC:	STA	3,GW3
;//	STA	2,FINST
	STA	0,GFS
	INC	0,1
	LOAD
	SGZ	0,0	;// LENGTH OF STRING
	 JMP	@GW3
	STA	0,LHALF	;// COUNT
	ZER	0,0
	STA	0,GSBC
;//	LDA	2,FINST
	JSR	GFCHC	;// FIRST TIME THROUGH
	SKIP
GFSLP:	 JSR	GFCHC1	;// SOMEWHAT FASTER
	JSR	@.PNB
GSBC:	0
GFS:	0
	DSZ	LHALF
	 JMP	GFSLP
	JMP	@GW3
 
.SRBYT:	SRBYTE
 
;//	PUT A CHARACTER INTO A FILE	 PFCHC
;//	 AC0 IS CHARACTER
;//	 AC2 IS FILE INSTANCE
 
PFCHC:	;//	STA	2,FINST	;// ENTRY BELOW IF FINST IS SET 'GLOBALLY'
PFCHC3:	STA	3,G3
	STA	0,CH
	LDA	1,C3
	ADD	2,1
	LOAD
	STA	0,PSTR	;// STRING INSTANCE
;//	LDA	2,FINST
	JSR	@.LNST
	BYTEC
	STA	0,PBC
	SP	0,0	;// BC >= 0?
	 JMP	PPAG	;// GET NEW PAGE
	JMP	PFCHC2

PFCHC1:	 STA	3,G3	;// ENTRY PT FOR WRITING BYTES TO SAME FILE
	 STA	0,CH
PFCHC2:	JSR	@.LNST
	NUMCH
	LDA	1,PBC
PLIM:	SGE	1,0
	 JMP	PDIRT
	LDA	3,C1000
	SLT	1,3	;// BC < 1000?
	 JMP	PPAG	;// GET NEW PAGE
	INC	1,0	;// NUMCH _ BC+1
	JSR	@.SNST	;// FASTER THAN GOING THROUGH PPAG
	NUMCH
	ONE	0,0	;// LABEL BLOCK DIRTY
	JMP	PDSET
PDIRT:	JSR	@.LNST
	DIRTY
	SZE	0,0	;// SET DIRTY WORD IF NOT ALREADY SET
	 JMP	PCH
	NIL	0,0	;// DATA DIRTY ONLY
PDSET:	JSR	@.SNST
	DIRTY
PCH:	LDA	0,PBC
	INC	0,0
	JSR	@.SNST	;// UPDATE BYTE COUNT
	BYTEC
	LDA	0,CH
	LDA	1,RBMSK
	AND	1,0	;// PNB DOESN'T MASK!
	JSR	@.PNB	;// PUT NEXT BYTE INTO A SMALLTALK STRING
PBC:	0
PSTR:	0
	JMP	@G3
G3:	0
GW3:	0
CH:	0
LHALF:	0
;// FINST:	0
 
;//	PUT A WORD INTO A FILE
 
PFWDC:	STA	3,GW3
	STA	0,LHALF
	JSR	EVPTR	;// MAKE SURE WORD BOUNDARY, PRESERVE AC0
	MOVS	0,0	;// LEFT BYTE FIRST 
	JSR	PFCHC
	LDA	0,LHALF
	JSR	PFCHC1
	JMP	@GW3

 PPAG:	INC	2,1	;// DIRECTORY OF FILE POINTS TO BITTABLE
	LOAD	
	INC	0,1
	INC	1,1
	LOAD
;//	LDA	2,FINST	;// IF THIS FILE IS NOT BITTABLE MUST SAVE
	SNE	0,2	;// ONE LEVEL OF STATE (PSTR,[JMP@G3],
	 JMP	BITTB	;// G3, GW3, FINST,CH,LHALF)
	JSR	BLTC	;// SET UP BLT
	0+PSTR-1-.	;// WHAT TO START SAVING -1, OFFSET
	1+SAV+VSAV-1-.	;// WHERE TO PUT IT +COUNT-1, OFFSET
	-VSAV		;// NEGATIVE WORD COUNT

	LDA	0,PBC
	NIL	1,1
	JSRII	.SWBYT	;// FILE INSTANCE STILL IN AC2
	 NIL	3,3,SKP	;// ERROR
	ZER	3,3
	STA	3,ERR
	STA	1,PBC

	JSR	BLTC	;// COPY BACK
	0+SAV-1-.
	1+PSTR+VSAV-1-.
	-VSAV		;// THIS MANY WORDS
	ISZ	ERR	;// AC2 STILL HAS FILE INSTANCE
	 JMP	PFCHC2	;// SOME RECHECKING. NUMCH =0 ON NEW PAGES.
	JMP	@G3
 
BITTB:	LDA	0,PBC
	NIL	1,1
	JSRII	.SRBYT	;// DON'T WRITE BITTABLE AFTER EOF
	 JMP	@G3
	STA	1,PBC
	JMP	PLIM

;//	PUT A STRING/INTEGER/FILE INTO A FILE	PFSTRC
;//	 AC0 IS INSTANCE TO READ FROM
 
PFSTRC:	STA	3,GW3
;//	STA	2,FINST
	STA	2,PSBC	;// FOR FILE COPY
	STA	0,PFS
	JSR	@.ISIT	;// IS SOURCE A STRING?
	SCLAS
	 JMP 	PFFIL	;// FILE OR INTEGER
	INC	0,1	;// STRING LENGTH
	LOAD
	SGZ	0,0
	 JMP	@GW3
	STA	0,LHALF	;// COUNT	LDA	2,PSBC
 	;// FILE INSTANCE	ZER	0,0
	STA	0,PSBC	;// BEGINNING OF STRING	ONE	0,0	STA	0,FIRST	;// FLAG FOR PFCH ENTRY
PFSLP:	JSR	@.GNB
PSBC:	0
PFS:	0	DSZ	FIRST	;// FILE CONTEXT STILL THERE	 JMP	.+3	;// YES	JSR	PFCHC3	SKIP	 JSR	PFCHC1	;// SAME FILE ETC.
	DSZ	LHALF
	 JMP	PFSLP
	JMP	@GW3

PFFIL:	JSR	@.ISIT	;// IS SOURCE ANOTHER FILE?
	FCLAS
	 JMP	PFINT	;// NO, ASSUME IT'S AN INTEGER
PFFLP:	LDA	2,PFS	;// SOURCE
	JSRII	.EOF	;// END OF FILE? (WILL YIELD EXTRA NULL BYTE
	 JMP	@GW3	;// IF EMPTY LAST PAGE. OTHER STOPPING RULES
	JSRII	.GFCH	;// GET A CHARACTER
	LDA	2,PSBC	;// DESTINATION
	JSR	PFCHC	;// PUT IT ELSEWHERE
	JMP	PFFLP

PFINT:	JSR	@.IVAL	;// CONVERT AC0 TO INTEGER
	LDA	2,PSBC
	JSR	PFCHC3	;// SINGLE CHARACTER
	JMP	@GW3
 
C1000:	1000
.EOF:	EOF
.SWBYT:	SWBYTE
.GFCH:	GFCH
ERR:	.-.
B3:	.-.FIRST:	.-.

BLTC:	STA	3,B3
	LDA	0,0,3	;// SOURCE-1, OFFSET
	ADD	3,0	;// ADD PC
	LDA	1,1,3	;// DEST-1, OFFSET
	ADD	3,1
	LDA	3,2,3	;// NEG WORD COUNT
	BLT
	LDA	3,B3
	JMP	3,3

SAV:	.BLK	VSAV	;// FOR PSTR,(JMP @G3),G3,GW3,CH,LHALF
 
	.END
