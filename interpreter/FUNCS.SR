	.TITL	FUNCS

	.GETNOLIST	"SMALL.OPS"
	.GETNOLIST	"SMALL.SYMS"
	.GETNOLIST	"SMALL.PARMS"
;	***NOTE ALL STATICS IN THIS MODULE MUST BE REFERRED TO 
;	IN PAGE1.SR, SO THAT THEY CAN BE RELOCATED WHEN FUNCS.SR
;	GETS MOVED***
	.ZREL	;//ENTRY POINTS
.IVAL:	IVAL
.SRET:	SRETN
.PUT:	PUT
.GETT:	GET
.FIND:	FIND
.SPUT:	SPUT
.SVAL:	SVAL
.SVLI:	SVLI
.SGET:	SGET
.ISIT:	ISIT
.INDX:	INDX
.INTN:	INTN
	.SREL
FIRSTOFFUNCS:	SIZEC
STCALL:	STCALC
NQERR:	QERR
NERR:	ERR
GADDR:	GADDRC
ALERRS:	ALERR
CACTS:	CACT
ARTBS:	ARTAB
	.NREL
SIZEC:	LASTOFCODE-.
GTER:	JSR	@.QERR
	.TXT	"null instance."
;
;	/* SIMPLE GET */	LIKE GET, BUT AC2 IS TABLE, NOT AREC
;	AND NAME(AC1) IS TAKEN LITERALLY (WILL HAVE REMOTE BIT IF DESIRED)
SGET:	INC	3,3		;SKIP RETURN IF SUCCEED
	STA	3,GETRT
	STA	1,NAME 
	LDA	0,C4
	INC	2,1
	ADD	0,2
	STA	2,TBL0		;TABLE BASE
	LOAD
	LDA	1,NAME 
	ANDZL	0,1		;AND NAME WITH CLASS MASK
	ADD	2,1
	STA	1,GCHEK		;FOR TEST OF REPEAT
	MOVZL	0,0
	ADD	2,0
	STA	0,TBLEND	;FOR TEST OF WRAP-AROUND
	LDA	2,NAME
;
SGET2:	LOAD		;AC2 CARRIES NAME THRU LOOP
	SNN	0,0
	 JMP	GET7	;EMPTY SLOT
	SNE	2,0
	 JMP	SGET3	;FOUND NAME
	INC	1,1
	INC	1,1	;SIMPLE INC FOR NEXT PROBE
	LDA	3,TBLEND
	SLEU	1,3
	 LDA	1,TBL0	;WRAP AROUND TABLE
	LDA	3,GCHEK
	SNE	3,1
	 JMP	GET7	;TABLE FULL, NO FIND
	JMP	SGET2	;LOOP
;
SGET3:	INC	1,1
	JMP	GET5
;
;	/* SIMPLE PUT */	CORRESPONDING VERSION OF PUT
SPUT:	STA	0,PVAL
	STA	3,PRET
	JSR	SGET
	SKIP
	JMP	PUT2		;FOUND
	STA	0,TEMP1
	JMP	PUTT1		;NOT FOUND
GETRT:	0
; 
;	/* GET (LOOKUP) */
;	JSR	GET	;AC1=NAME, AC2=ACTIVN REC
GET:			;AC0 RETURNS VAL, GADDRC VMEM ADDR OF PAIR
	INC	3,3		;SECOND RETURN IF SUCCEED
	STA	3,GETRT
	STA	2,AREC 
	STA	1,NAME 
	MOV	2,1
	LOAD			;GET CLASS PTR IN ACT'N REC
	LDA	2,C4
	ADD	0,2
	STA	2,TBL0		;TABLE BASE
	INC	0,1
	LOAD
	LDA	1,NAME 
	ANDZL	0,1		;AND NAME WITH CLASS MASK
	ADD	2,1
	STA	1,GCHEK		;FOR TEST OF REPEAT
	MOVZL	0,0
	ADD	2,0
	STA	0,TBLEND	;FOR TEST OF WRAP-AROUND
	LDA	2,NAME
;
GET2:	LOAD		;AC2 CARRIES NAME THRU LOOP
	SNN	0,0
	 JMP	GET7	;EMPTY SLOT
	LDA	3,MXATM
	AND	0,3
	SNE	2,3
	 JMP	GET3	;FOUND NAME
	INC	1,1
	INC	1,1	;SIMPLE INC FOR NEXT PROBE
	LDA	3,TBLEND
	SLEU	1,3
	 LDA	1,TBL0	;WRAP AROUND TABLE
	LDA	3,GCHEK
	SNE	3,1
	 JMP	GET7	;TABLE FULL, NO FIND
	JMP	GET2	;LOOP
;
GET3:	INC	1,1
	MOVZL	0,0,SNC		;TEST DESCRIPTOR FLAGS
	 JMP	GET5		;VAL IN TEMPLATE
	MOVZL	0,0,SNC
	 JMP	GET4		;VAL IS AREC OFFSET
;
	LOAD			;  /* INSTANCE FIELD
	INC	0,2		;STACHE OFFSET(+1 FOR TYPE)
	LDA	1,AREC
	LDA	0,INSOF
	ADD	0,1
	LOAD			;GET INSTANCE PTR
	SNN	0,0
	JMP	GTER
	MOV	2,1
	JMP	GET4A
;
GET4:	LOAD			;  /* AREC FIELD
	LDA	1,AREC
GET4A:	ADD	0,1		;ADD OFFSET
;
GET5:	STA	1,GADDRC	;  /* TEMPLATE FIELD
	LOAD			;SAVE ADDR AND LOAD
	JMP	@GETRT
;
GET7:	STA	1,GADDRC
	LDA	3,GETRT		;FAIL TAKES FIRST RETURN 
	JMP	-1,3 
;
AREC:	0 
NAME:	0 
INSOF:	INST	;OFFSET OF INSTANCE IN AREC
TBL0:	0
TBLEND:	0
GCHEK:	0
GADDRC:	0
TEMP1:	0
; 
;	/* PUT (INSTALL) */	;LIKE FIND, BUT STORES INTO
PUT:	STA	0,PVAL		;SAVE VALUE TO BE STORED
	STA	3,PRET		;AND RETURN 
	JSR	FIND		;LOCATE 'NAME'  
	JMP	PUTT1		;GET FAILED
PUT2:	LDA	0,PVAL
	JSR	@.REFI		;INC REF CT
	LDA	1,GADDRC
	JSR	@.STREF		;STORE IN, FREEING PREV GUY
	JMP	@PRET		;RETURN
PUTT1:	LDA	0,TEMP1
	SNL	0,0		;MAKE SURE FAIL NAME FIELD WAS NIL
	JMP	PTER		; (ERROR) 
	LDA	1,GADDRC		;GET LAST FAIL ADDR
	LDA	0,NAME		;THEN INSTALL NAME THERE 
	STOR	 
	ISZ	GADDRC		;FOLLOWED BY VALUE
	JMP	PUT2
PVAL:	0	;PUT'S VALUE
PRET:	0	;PUT'S RETURN
PTER:	JSR	@.QERR
	.TXT	"table overflow."
; 
;	/* FIND */
FIND:		;JUST LIKE GET, BUT ONLY FAILS AFTER 
;		 GLOBAL CHAIN HAS BEEN EXHAUSTED 
	INC	3,3		;SECOND RETURN IS NORMAL
	STA	3,FINDX		;SAVE RETURN
	LDA	3,MXATM
	SLEU	1,3
	 JMP	FERR
	JSR	@.GETT
	SKIP
	 JMP	@FINDX	;FOUND IT HERE
	STA	0,TEMP1
	LDA	3,@.ARTB
	LDA	1,NAME
ARCK:	LDA	0,0,3	;LOOP TO CHECK FOR ACTIVATION FIELDS
	SNN	0,0
	JMP	FND3A
	INC	3,3
	SEQ	0,1
	 JMP	ARCK
	LDA	1,ART2-ARTAB-1,3
	LDA	0,AREC
	SP	1,1
	 JMP	@FINDX
	ADD	0,1
	STA	1,GADDRC
	LOAD
	 JMP	@FINDX
FIND3:	JSR	@.GETT		;LOOP TO CHASE GLOBAL CHAIN
	SKIP 
	 JMP	@FINDX		;FOUND IT (RETURN VAL) 
	STA	0,TEMP1		;SAVE FAIL NAME FIELD
FND3A:	LDA	2,AREC
	LDA	1,GLDIS
	ADD	2,1		;GET GLOBAL POINTER
	LOAD	
	SNN	0,0		;IF GLOBAL LINK IS NIL
	JMP	FIND4		;THEN FAIL
	MOV	0,2		;CONTEXT _ GLOBAL 
	LDA	1,NAME
	JMP	FIND3		;TRY AGAIN
FIND4:	LDA	3,FINDX		;FAIL TAKES FIRST RETURN
	JMP	-1,3 
.TOPL:	TOPLEV	;ADDR OF TOPLEVEL BINDING TABLE
GLDIS:	GLOB	;OFFSET OF GLOBAL IN AREC
FINDX:	0
;
;	/* TABLES FOR GET */
.ARTB:	ARTBS
ARTAB:	QAREC	;HASHES OF AREC FIELD NAMES
	QSELF
	QMESS
	QGLOB
	QRETN
	QCLAS
ART2:	-1	;OFSETS OF THE FIELDS (AREC FLAGGED BY -1)
	INST
	MESS
	GLOB
	RETN
	CLAS
;
FERR:	JSR	@.QERR
	.TXT	"Non-atomic symbol in lookup."
; 
;	/* GET MASK OR NVARS */	;AC2 POINTS TO CLASS DEF 
GNVR:	INC	2,2		;THIRD WORD OF CLASS HEADER    
GMSK:	STA	3,GRET
	INC	2,1
	LOAD			;2ND WORD OF CLASS HEADER
	JMP	@GRET		;RETURN 
GRET:	0 
; 
;	/* CREATE ACTIVATION REC */ 
CACT:	STA	3,HOLD3		;AC2 POINTS TO CLASS 
	JSR	GNVR		;GET NO. VARS IN CLASS 
	LDA	2,NSYS
	SUB	0,2
	STA	2,HAL2
	DSZ	HAL2		;-(NLOCALS+1)
	LDA	2,BHMEM 
	MOV	2,1
	SUB	0,2		;BLOCK SIZE IN AC0
	LDA	0,TLMEM
	SGTU	2,0		;TEST END OF MEM
	JMP	ALERR
	STA	2,BHMEM		;UPDATE BHMEM 
	NIL	0,0
HAL3:	ADD	0,1	;DEC AC1
	STOR		;FILL ANY LOCALS WITH NIL
	ISZ	HAL2
	JMP	HAL3
	LDA	2,BHMEM
	JMP	@HOLD3		;BLOCK PTR RETURNED IN AC2
HAL2:	0
HOLD3:	0
NSYS:	ARG0	;NO. SYS VARS IN AREC (=OFFSET OF FIRST LOCAL)
ALERR:	JSR	SRETN
	JMP	.+2	;THIS MESSAGE WANTS A POP-UP FIRST
	JMP	.-2
	LDA	0,ERLOC	;CHECK FOR ENDLESS LOSS OF SPACE
	SZE	0,0
	JMP	@.EVAL	;FOR WHAT ITS WORTH
	JSR	@.QERR
	.TXT	"I've run out of memory"
;
;	/* SMALLTALK RETURN */
SRETN:	STA	3,SRE1
	LDAF	RETN	;GET RETURN POINTER
	SNN	0,0
	JMP	@SRE1	;IMMED RETURN IF TOP LEVEL
	STA	0,SRE2
	JSR	HFRE	;FREE THIS ACTIVATION
	LDA	0,SRE2
	JSR	@.SSLF	;SELF _ CALLER
	LDA	3,SRE1
	JMP	1,3	;SKIP-RETURN
SRE1:	0
SRE2:	0
; 
;	/* FREE AN ACTIVN REC */	;JUST A STACK FOR NOW 
HFRE:	STA	3,HFR5
	LDAF	CLAS
	MOV	0,2
	JSR	GNVR
	LDA	1,.INS
	SUB	0,1
	STA	1,HFR2		;(-) NO. FIELDS TO RELEASE
	LDA	2,SELF
	ADD	0,2
	STA	2,HFR4		;NEW BHMEM
	ADD	1,2
	STA	2,HFR1		;POINTER TO FIRST LOCAL (=INST)
HFR3:	LDA	1,HFR1
	LOAD	
	JSR	@.REFD		;RELEASE LOCAL VARS
	ISZ	HFR1
	ISZ	HFR2
	JMP	HFR3
	LDA	1,BHMEM
	LDA	2,SELF
	SEQ	1,2		;IF AREC AT TOP OF STACK, THEN
	JMP	@HFR5
	LDA	1,HFR4		;UPDATE BHMEM
	STA	1,BHMEM
	JMP	@HFR5 
HFR1:	0
HFR2:	0
HFR5:	0
HFR4:	0
.INS:	INST
;
;	/* STORE INTO VALUE */ - AND REF CT
SVAL:	LDA	1,VALUE
	SNE	0,1
	JMP	0,3
	STA	0,SV0
	STA	3,SV3
	LDA	0,VALUE
	JSR	@.REFD		;DECREMENT REF CT OF OLD VALUE
	LDA	0,SV0
	JSR	@.REFI		;INCREMENT REF CT OF NEW VALUE
	STA	0,VALUE
	JMP	@SV3		;RETURN
SVLI:	;/* SAME WITHOUT REF CT
	STA	0,SV0
	STA	3,SV3
	LDA	0,VALUE
	JSR	@.REFD
	LDA	0,SV0		;LOAD ARG
	STA	0,VALUE		;INTO VALUE
	JMP	@SV3
SV0:	0
SV3:	0
;
;	/* SMALLTALK ERROR HOOK */
QERR:	STA	3,ERLOC
	JSRII	.PRON	;TURN ON DISPLAY
	LDA	0,.QEROR
	JSR	STCALC
	JSR	@.SRET	;POP UP TO TOP LEVEL
	JMP	.+2
	JMP	.-2
	JMP	@.EVAL
ERR:	JSR	QERR
	.TXT	"Smalltalk is confused."
;
;	/* CALL SMALLTALK */
STCALC:	STA	0,TOKEN	;MAKE EVAL THINK IT JUST PICKED UP THIS TOKEN
	LDA	0,SELF
	STA	0,GLOBX
	STA	0,MESSX
	MOV	3,0
	STAF	MODE
	JSRII	.EFI
;
.QEROR:	QEROR
.PRON:	PRTON
.EFI:	EFINDS
;
;	/* INDEX */ - LINEAR SCAN FOR MATCH TO AC0
INDX:	LDA	1,0,3		;GET NUMBER OF ENTRIES
	STA	1,INDX1
	ZER	2,2		;AC2 RETURNS INDEX (OR NIL)
INDX2:	INC	3,3
	LDA	1,0,3		;COMPARE TABLE ENTRY
	SNE	0,1
	JMP	INDX3		;BRANCH IF EQUAL
	INC	2,2
	DSZ	INDX1
	JMP	INDX2
	NIL	2,2		;NOT FOUND
	JMP	1,3
INDX3:	LDA	1,INDX1		;ADD REMAINING COUNT
	ADD	1,3		;TO GET RETURN ADDR
	JMP	0,3
INDX1:	0
;
;	/* LOAD INTEGER VALUE */
IVAL:	STA	3,IVRET
	JSR	@.ISIT	;CHECK FOR INTEGER
	NCLAS
	JMP	NOTI	;NOPE
	MOV	1,0	;**.ISIT LEAVES VAL IN AC1 !
	JMP	@IVRET
NOTI:	JSR	@.ISIT
	FPCLAS		;NOW CHECK FOR FLOATING
	JMP	IVERR	;NOPE
	MOV	0,1	;YES, FIX IT!
	ZER	0,0
	JSRII	.FLD	;LOAD FLOATING REG
	JSRII	.FTR	;AND RETURN IPART
	JMP	@IVRET
.FTR:	FTR	;TRUNCATE RTN
.FLD:	FLD	;FLOATING LOAD RTN
IVERR:	JSR	@.QERR
	.TXT	"Non-numeric or undefined operand."
IVRET:	0
; 
;	/* NUMERIC INTERN */
;	JSR	INTN		;INTERN NUMBER PASSED IN AC0
INTN:				;RESULT RETURNED IN AC0
	LDA	1,MSI1
	ADD	0,1
	SP	1,1	;CHECK IF .GE. SMALLEST SML INT
	 JMP	NEWI	;NOPE
	LDA	2,SIBAS
	ADD	1,2
	LDA	1,.MXNUM
	SLEU	2,1	;CHECK IF .LE. LARGEST SML INT
	 JMP	NEWI	;NOPE
	MOV	2,0
	JMP	0,3	;YEP, RETURN THE ADDRESS
;
NEWI:	STA	3,INT3	;OTHERWISE MAKE UP A NEW ONE 
	STA	0,INT0
	LDA	0,C2
	JSR	@.LALO
	MOV	2,1	;INSTALL TYPE
	LDA	0,NCLAS
	STOR
	LDA	0,INT0	;AND VALUE
	INC	1,1
	STOR
	NIL	0,0
	ADD	1,0	;RETURN POINTER
	JMP	@INT3
INT0:	0
INT1:	0
INT3:	0
MSI1:	0-SINT1
;
;	/* TYPE CHECK */
;	JSR	ISIT	;AC0=POINTER OF UNKNOWN TYPE
;	<TYPE>		;KNOWN CLASS ADDR SUCH AS NCLAS
;	...NO
;	...YES
ISIT:	LDA	1,.MXNUM
	SGTU	0,1	;CHECK FOR SMALL INTEGER
	 JMP	SMLINT
OHNO:	STA	0,ISAV0
	STA	3,ISAV3
	MOV	0,1
	DLOAD		;GET TYPE/VALUE
	LDA	2,RCMSK
	AND	2,0	;MASK OUT REF CNT
	LDA	3,ISAV3
	LDA	2,@0,3	;GET ARG(TYPE HES CHECKING FOR)
	SNE	0,2
	INC	3,3	;SKIP-RETURN IF MATCHES
	LDA	0,ISAV0
	JMP	1,3	;OTHERWISE JUST RETN AFTER ARG
;
SMLINT:	LDA	1,SIBAS	;MIGHT BE A SMALL INTEG
	SLEU	1,0
	 JMP	OHNO	;NO, TOO SMALL
	LDA	1,NCLAS	;YES, IT IS A SMALL INTEGER
	LDA	2,@0,3
	SEQ	2,1	;BUT IS HE CHECKING FOR NUMBER??
	 JMP	1,3	; NOPE
	LDA	1,SIOFF	;YEP, GET VAL INTO AC1(FOR IVAL)
	ADD	0,1
	JMP	2,3	;AND SKIP-RETN
ISAV0:	0
ISAV3:	0
SIBAS:	SINTB		;BASE (ADDR) OF SML INTS
SIOFF:	SINT1-SINTB	;OFFSET OF VAL FROM ADDR OF SMALL INTS
.MXNUM:	MXNUM		;HIGHEST SML INT ADDR
LASTOFCODE:	0
	.END
