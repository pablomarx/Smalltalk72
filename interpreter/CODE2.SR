	.TITL	CODE2
	.GETNOLIST	"SMALL.OPS"
	.GETNOLIST	"SMALL.SYMS"
	.GETNOLIST	"SMALL.PARMS"
;	***NOTE ALL STATICS IN THIS MODULE MUST BE REFERRED TO 
;	IN PAGE1.SR, SO THAT THEY CAN BE RELOCATED WHEN CODE2.SR
;	GETS MOVED***
	.SREL	;//ENTRY POINTS
LEECH:	LEECHC
FORMK:	FORX
STRVE:	STRVEC
KYBD:	KYBDC
APLY1:	APLY1C
FOR1:	FOR1C
ERR1S:	ERR1
XEQ:	XEQC
USRX:	USRXC
FIRSTOFCODE2:	SIZEC
	.NREL
SIZEC:	LASTOFCODE-.
;//
;//	/* LIST EVAL
STV3:	JSR	SKIPV	;//CHECK IT'S A VECTOR
	JMP	STVA1	;//NOPE
	JSR	@.AMPC
LEVAL:	LDAF	INST
	INC	0,0
	STAF	PC		;//PC _ BODY OF LIST
	LDAF	MESS
	JSR	@.INTN		;//SAVE MESSAGE (AS INTEG)
	STAF	ARG0
	LDA	0,SELF		;//MESSAGE _ SELF
	STAF	MESS
	NIL	0,0
	JSR	@.SVAL
;//
LEVLP:	LDA	0,.QPER		;//TEST FOR .QPER
	JSR	@.PEEK
	JMP	PER
	SNN	0,0		;//OR NIL
	JMP	LEND
	JSR	@.FECH		;//EVAL THIS TOKEN
	JMP	LEVLP
PER:	JSR	@.AMPC		;//SKIP OVER THE .QPER
	NIL	0,0
	JSR	@.SVAL		;//NIL THE VALUE
	JMP	LEVLP
;//
LEND:	LDAF	ARG0		;//RESTORE MESSAGE
	JSR	@.IVAL
	STAF	MESS
	JMP	@.ARET		;//AND RUN THE RESULT
;//
;//	/* ERRORS AND VECTOR TEST
ERR1:	JSR	@.QERR
	.TXT	"Missing right bracket."
SKIPV:	STA	0,SK0	;//TEST IF VECTOR, FOR SHARED CODE
	STA	3,SK3
	LDAF	CLAS	;//ONLY AC0 IS PRESERVED
	LDA	1,LSCLA
	SNE	0,1
	ISZ	SK3	;//SKIP RETURN IF VECTOR
	LDA	0,SK0
	JMP	@SK3
SK0:	0
SK3:	3
;//
;//	/* STRING AND VECTOR CODE */
;//
;//	/* CHECK FOR IMPLICIT EVAL
MPC1:	0
STRVEC:	LDAF	INST		;//ISNEW ?
	SNN	0,0
	JMP	STV4
	JSR	SKIPV
	JMP	STRVA
	LDAF	MESS		;//TEST  MESS.PC.1 = INST
	INC	0,1
	LOAD
	MOV	0,1
	STA	1,MPC1
	LOAD
	STA	0,TEMP
	LDAF	INST
	LDA	1,TEMP
	SEQ	0,1
	JMP	STRVA		;//NO
	DSZ	MPC1
	LDA	1,MPC1
	LOAD
	LDA	1,.QUOTE		;//TEST PRECEDED BY .QUOTE (CROCK!!)
	SEQ	0,1
	JMP	LEVAL
;//
;//	/* DISPATCH ON TOKEN
STRVA:	LDA	0,LBRAK
	JSR	@.PEEK		;//TEST FOR "["
	JMP	STV1
	LDA	1,.QLEN		;//TEST FOR "length"
	SNE	0,1
	JMP	STV2
	LDA	1,.QEVAL		;//TEST FOR "eval"
	SNE	0,1
	JMP	STV3
STVA1:	LDA	1,.QPER	;//TEST FOR "." OR NIL
	SNL	0,0
	SNE	0,1
	JMP	PASRT
	LDA	1,.QUEST		;//TEST FOR "?"
	SNE	0,1
	JMP	PASRT
	JSR	@.APC	;//SKIP OVER  ?()  CLAUSE
	JSR	@.APC
	JMP	@.EVAL	;//AND RESUME
;//
;//	/* PICK UP SUBSCRIPT
STV1:	JSR	@.FECH		;//FETCH SUBSCRIPT
	STAF	ARG0
	NIL	1,1		;//ARG0 ASSUMES VALUE'S REF CT
	STA	1,VALUE
	JSR	@.IVAL
	STA	0,SUBSC
	LDA	0,RBRAK	;//CHECK FOR LEFT BRACKET
	JSR	@.PEEK
	JMP	BOUND	;//FOUND IT
	LDA	1,.QTO	;//CHECK SUBSTRING KEYWORD "to"
	SEQ	0,1
	JMP	ERR1	;//NOPE
	JSR	@.AMPC	;//YEP, GOBBLE IT
	JSR	@.APC
	JSR	@.APC  
	INC	0,0
	STAF	PC	;//AND ENTER THE SUBSTRING CLAUSE
	JMP	@.EVAL
PEEK:	0	;//SAVE NEXT TOKEN
.QTO:	QTO	;//HASH OF "to"
.QUOTE:	QUOTE
;//
;//	/* CHECK BOUNDS
BOUND:	LDAF	INST
	INC	0,1
	LOAD
	LDA	1,SUBSC
	SGT	1,0
	SGZ	1,1
	JMP	ERR2		;//SUBSRIPT OUT OF BOUNDS
;//
;//	/* LOAD FROM
	LDA	0,.QLARO
	JSR	@.PEEK		;//TEST FOR "_"
	JMP	STVST
	LDAF	INST
	JSR	SKIPV
	JMP	STRLD		;//BRANCH IF STRING
	LDA	1,SUBSC
	ADD	0,1		;//INDEX INTO STRUCTURE
	INC	1,1
	LOAD
ARET:	JSR	@.SVAL		;//RETURN VALUE
	JMP	@.ARET
;//
;//	/* STORE INTO
STVST:	JSR	@.FECH		;//FETCH VALUE
	LDAF	ARG0
	JSR	@.IVAL
	STA	0,SUBSC
	LDAF	INST
	JSR	SKIPV
	JMP	STRST		;//BRANCH IF STRING
	LDA	1,SUBSC
	ADD	0,1		;//INDEX INTO STRUCTURE
	INC	1,1
	STA	1,SUBSC	;//(SAVE ADDR)
	LOAD
	STA	0,TEMP
	LDA	1,SUBSC
	LDA	0,VALUE		;//INSTALL VALUE
	STOR
	JSR	@.REFI		;//INCREMENT REF CT OF NEW ENTRY
	LDA	0,TEMP
	JSR	@.REFD	;//DELAYED REFD OF OLD ENTRY
	JMP	@.ARET		;//ACTIVE RETURN
;//
;//	/* RETURN LENGTH
STV2:	JSR	@.AMPC
	LDAF	INST
	INC	0,1
	LOAD
INRET:	JSR	@.INTN		;//MAKE AN INTEGER
	JSR	@.SVLI
	JMP	@.ARET		;//RETURN MAX LENGTH
;//
;//	/* CREATE A NEW STRUCTURE
STV4:	JSR	@.FECH
	JSR	@.IVAL
	SP	0,0
	JMP	ERR2
	JSR	SKIPV
	ONE	2,2,SKP
	LDA	2,C2
	JSRII	.SVALO	;IN RDSCAN.SR
	STAF	INST
	JSR	@.SVAL
	JMP	@.ERET	;//RETURN PASSIVELY
.SVALO:	SVALO
;//
;//	/* TEMPS, VARS, ETC.
.MAKI:	MKINS
SPTR:	0
SUBSC:	0	;//HOLDS VALUE OF SUBSCRIPT
TEMP:	0
LBRAK:	QLBRA	;//HASH OF "["
RBRAK:	QRBRA	;//HASH OF "]"
.QLEN:	QLEN	;//HASH OF "length"
.QEVAL:	QEVAL	;//HASH OF "eval"
ERR2:	JSR	@.QERR
	.TXT	"Subscript out of bounds"
;//
;//	/* PASSIVE RETURN */ - IF END OF MESSAGE
PASRT:	LDAF	INST		;//RETURN #@INSTANCE
	JSR	@.SVAL
	JMP	@.ERET
;//
;//	/* STRING LOAD
STRLD:	JSR	STRL1
	AND	2,0
	JMP	INRET	;//CREATE AND RETURN INTEGER
STRL1:	STA	3,STL1X
	LDA	1,SUBSC
	INCZR	1,1		;//SHIFT SUBSCRIPT
	ADD	0,1
	INC	1,1
	STA	1,SPTR
	LOAD			;//FETCH WORD
	LDA	1,SUBSC
	MOVR	1,1,SZC
	MOVS	0,0		;//SWAP IF ODD BYTE
	LDA	2,RBMSK
	JMP	@STL1X
STL1X:	0
;//
;//	/* STRING STORE
STRST:	JSR	STRL1		;//FETCH OLD WORD
	COM	2,2
	AND	2,0		;//MASK OUT OLD BYTE
	STA	0,TEMP
	LDA	0,VALUE
	JSR	@.IVAL
	LDA	1,TEMP
	LDA	2,RBMSK
	AND	2,0
	ADD	1,0		;//ADD IN NEW BYTE
	LDA	2,SUBSC
	MOVR	2,2,SZC
	MOVS	0,0		;//UNSWAP IF ODD BYTE
	LDA	1,SPTR
	STOR
	JMP	@.ARET
;//
;//	/* NOVA keyboard interface routine
;//
KYBDC:	LDA	0,.QLARO
	JSR	@.PEEK	;//THIS IS LIKE SMALLTALK "%"
	JMP	OUTPT	;//BRANCH IF FOUND "_"
	LDA	0,VALUE	;// 0 WAITS FOR INPUT / 1 TESTS IF ACTIVE
	JSR	@.IVAL
	SZE	0,0
	JMP	KBACT
	JSR	@.TGET	;///* GET CHAR
	JMP	INRET	;//MAKE AN INTEGER, AND REETURN ACTIVE
KBACT:	JSRII	.KBCK	;//SAME BUT
	JMP	@.FALS	;// ! FALSE IF IDLE
	JMP	INRET	;// ELSE ! NEXT CHAR (WITHOUT DELETING)
.KBCK:	KBCK
;//
OUTPT:	JSR	@.FECH	;//FETCH VAL - LIKE SMALLTALK ":"
	LDA	0,VALUE	;//PICK UP THE RESULT
	JSR	@.IVAL	;//GET INTEGER VALUE - INVERSE OF .INTN
	JSR	@.TPUT	;///* PRINT CHAR
	JMP	@.ERET	;//RETURN
;//
;//	/* APPLY */ ARG WILL RUN WITH GLOBAL'S MESSAGE
APLY1C:	ONE	1,1
	JSR	@.LARG
	SNL	0,0	;//IF ARG1 IS NIL, THEN
	JMP	APTO
	LDAF	GLOB
	LDA	1,.MES	;//PUT GLOBAL.MESSAGE
	ADD	0,1
	LOAD
APLY2:	STAF	MESS	;//INTO MESSAGE
	LDAF	ARG0
	JSR	@.SVAL
	JMP	@.ARET	;//AND RUN THE ARG
APTO:	INC	0,0
	STAF	PC	;//APPLY TO LIST - PC DELVES IN
	LDA	0,C3
	STAF	MODE	;//CROC TO CAUSE RETURN EVEN IF NOT LIST END
	LDA	0,SELF
	JMP	APLY2	;//MESS _ SELF, AND RUN ARG
.MES:	MESS
;// 
;//	/* LEECH */	 - GENERAL OBJECT MUNGER
LEECHC:	LDA	0,LBRAK	;//PARSE SUBSCRIPT
	JSR	@.PEEK
	SKIP
	JMP	@.EVAL
	JSR	@.FECH	JSR	@.REFI	ZER	1,1	JSR	@.SARG
	LDA	0,RBRAK
	JSR	@.PEEK
	SKIP
	JSRII	.ER1
	LDA	0,MPERS	;//AMPERSAND MEANS 'BITS' (NOT POINTER)
	JSR	@.PEEK
	ONE	0,0,SKP
	ZER	0,0	JSR	@.REFI	ONE	1,1	JSR	@.SARG
	LDA	0,.QLARO	;//CHECK FOR LEFT-ARROW
	JSR	@.PEEK
	JMP	LCH1
;//	*READ FROM
	JSR	LCHIN
	 JMP	RDBITS
	JSR	@.SVAL
	JMP	@.ARET
RDBITS:	JSR	@.INTN	JSR	@.SVLI
	JMP	@.ARET
;//	*STORE INTO
LCH1:	JSR	@.FECH	;//FETCH NEW VALUE
	STA	0,NEW
	JSR	LCHIN	;//GET ADDR	 JMP	LDBITS
	LDA	0,NEW	JSR	@.STREF
	JMP	@.ARETLDBITS:	STA	1,FIELD	;//SAVE ADDR	LDA	0,NEW	JSR	@.IVAL	LDA	1,FIELD	STOR	JMP	@.ARET
BITS:	0
FIELD:	0
OLD:	0
NEW:	0
.EVTK:	EVTKS
;//
LCHIN:	;//AC1_PTR+FIELD.
	STA	3,LCHIX	LDAF	ARG0	JSR	@.IVAL	STA	0,FIELD	ONE	1,1	JSR	@.LARG	STA	0,BITS	;GOT FIELD AND BIT FLAG FROM ACTIV'N
	LDAF	INST
	INC	0,1
	LOAD		;//GET PTR
	LDA	1,FIELD
	ADD	0,1	LOAD		;//GET CONTENTS	LDA	2,BITS	SNZ	2,2	 ISZ	LCHIX	;SKIP-RETN IFF NOT BITS
	JMP	@LCHIX
LCHIX:	0
MPERS:	QMPER	;//HASH OF &
.ER1:	ERR1S
;
;
ITSADO:	LDA	0,FVAL
	LDA	1,SELF	;DO SHARES CODE OF FOR,
	LDA	2,INSP1	;EXCEPT INDUCTN VAR IS STACHED
	ADD	2,1	;WHERE ITS NAME WOULD NORMALLY BE
	LDA	2,C3	; (NAMELY IN 3RD AREC FIELD)
	ADD	2,1	;THIS CODE MAKES A REF TO THAT FIELD
	STOR
	JMP	RCAP
INSP1:	INST+1
;//
;//	/* FOR */ FAST LOOPING WITH INDUCTION VARIABLE
FOR1C:	NIL	0,0
	JSR	@.SVLI
	ONE	1,1
	JSR	@.LARG
	JSR	@.IVAL
	STA	0,FVAL
	LDA	1,C4
	JSR	@.LARG
	JSR	@.IVAL
	LDA	1,FVAL
	SUB	1,0
	JSR	@.INTN
	STA	0,FVAL	;//START-STEP
	LDAF	GLOB
	STA	0,T	;//PUT IT INTO INDUCTN VAR
	LDA	1,C3
	JSR	@.LARG
	SNN	0,0
	JMP	ITSADO
	MOV	0,1
	LDA	2,T
	LDA	0,FVAL
	JSR	@.PUT
RCAP:	MOV	1,0	;//CAPTURE REF OF VAR
	JSR	@.INTN
	STAF	ARG0	;//AS INTEGER IN ARG0
FORLP:	JSR	@.GARG	;//GET IVAL OF 1ST 3 VARS
	0
	3
	-1
	.VAR-.+3	;GARG'S WAY OF ADDRESSING
	LDA	1,.VAR
	LOAD		;//GET OLD VAL
	STA	0,T
	JSR	@.IVAL
	LDA	1,FSTEP
	ADD	1,0
	STA	0,FVAL	;//VAL _ VAL + STEP
	JSR	@.INTN
	LDA	1,.VAR
	STOR
	LDA	0,T
	JSR	@.REFD	;//RELEASE OLD VAL
	LDA	0,FVAL
	LDA	1,FSTEP
	LDA	2,FSTOP
	SP	1,1
	NEG	0,0,SKP	;//COMPLEMENT IF STEP<0
	SKIP
	NEG	2,2
	SLE	0,2
	JMP	@.ERET	;//DONE IF VAL<STOP
	LDA	1,C5
	JSR	@.LARG
	JSRII	.EVTK	;//AND EVAL THE EXPR
FORX:	JMP	FORLP	;//REPETITIVELY
FVAL:	0
.VAR:	0	;//LOCN OF INDUC VAR	*
FSTEP:	0	;//			** KEEP THESE TOGETHER
FSTOP:	0	;//			*
T:	0
;
;	/* TOPLEVEL RESTART */ DUBIOUS VALUE
USRXC:	LDA	0,C2
	STAF	MODE
	LDAF	CLAS
	MOV	0,2
	LDA	1,.QDO	;PC _ # DO
	JSR	@.SGET
	JSR	@.ERR
	INC	0,0
	STAF	PC
	JMP	@.EVAL
;
;	/* GENERAL NOVA OPERATION */
XEQC:	JSR	@.FECH
	JSR	@.IVAL
	STA	0,TOEX	;INSTR TO EXECUTE
	LDAF	INST
	ZER	1,1	;LOAD INST INTO CORE
	JSR	@.LSI
	AC0X-.
	1
	3
	LDA	0,AC0X
	LDA	1,AC1X
	LDA	2,AC2X
TOEX:	0	;**NOVA INSTRUCTION
	STA	0,AC0X
	STA	1,AC1X
	STA	2,AC2X
	JSR	@.INTN
	JSR	@.SVLI	;VLIUE RETURNED IS RESULTANT AC0
	LDAF	INST
	ONE	1,1	;LOAD CORE INTO INST
	JSR	@.LSI
	AC0X-.
	1
	3
	JMP	@.ARET
AC0X:	0
AC1X:	0
AC2X:	0;LASTOFCODE:	0
	.END
 @