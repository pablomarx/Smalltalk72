	.TITL	ALLOC

	.GETNOLIST	"SMALL.OPS"
	.GETNOLIST	"SMALL.SYMS"
	.GETNOLIST	"MICRO.PARMS"
	.ZREL	;//ENTRY POINTS
.alloc:	MKINC
.calloc:	MKINCC
.LALO:	LALO
.LAL8:	LAL8
RCMSK:	177770
	.SREL
REFCT:	REFCC
STACKS:	STACK
POPS:	POP
PUSHS:	PUSH
OVBASE:	OBASE
OVINIT:	OVIC
RERE:	REC
	.NREL
;
;//	/* MAKE INSTANCE */ AC0=SIZE(TOTAL), AC1=CLASS, AC0 RETURNS PTR
MKINCC:	STA	0,ISIZE
	STA	1,CLASS
	STA	3,MKRT
	JSR	@.LAL8	;//FOR CLASSES - 8-WD BOUNDARY
	JMP	MKI1
;
MKINC:	STA	0,ISIZE
	STA	1,CLASS
	STA	3,MKRT
	JSR	@.LALO	;//GET SOME STORAGE
MKI1:	STA	2,IPT1
	MOV	2,1
	LDA	0,CLASS
	STOR		;//INSTALL CLASS FIELD
	NIL	0,0
	JMP	NLP1
NILP:	INC	1,1
	STOR		;//NIL EACH WORD OF THE NEW INSTANCE
NLP1:	DSZ	ISIZE
	JMP	NILP
MAKX:	LDA	0,IPT1	;//RETURN POINTER
	JMP	@MKRT
IPT1:	0
ISIZE:	0
CLASS:	0
MKRT:	0
;
;	/* REFERENCE COUNT OVERFLOW TABLE */
;A linked table of (address,ref-ct,link).  If a 3-bit ref ct
;overflows to 7, then it is entered here with ov-count = 1, 
;and maintained here until the ov-count falls to 0, in which
;case the entry is deleted and the 3-bit ref ct is dropped to 6.
;
;If the table fills, then further new overflows will go to 7
;without getting an ov entry.  It will therefore hang at 7, and
;become garbage.  Also a save/load of VMEM will cause loss of all
;current ov entries with same garbaging effect.  Both of these
;loss situations are unlikely, as ref-cts tend to stay below 7
;except for brief periods of activation(of course, some special
;applications will make lots of ov ref-cts; we'll deal with
;those later).
;
OVSIZ=	40	;MUST BE POWER OF TWO
OVADR:	.BLK	OVSIZ	;ADDRESS TABLE
REFCT:	.BLK	OVSIZ	;REF CT TABLE
OBASE:
LINK:	.BLK	OVSIZ	;LINK TABLE
FREEP:	0			;MUST FOLLOW LINK TBL!!
HASH:	.BLK	OVSIZ	;HASH-LINK TABLE
;
OVIC:	STA	3,OVRET	;INIT TABLES (EACH TIME RELOAD VMEM)
	LDA	0,.OVS
	STA	0,OVCNT
	LDA	2,@.BASE
	ZER	0,0
	STA	0,LINK-OBASE,2	;ZERO IN 1ST LINK
OVILP:	STA	2,LINK-OBASE+1,2	;EACH LINK PTS TO PREV
	STA	0,HASH-OBASE,2 ;ALL HASH-LINKS SET TO ZERO
	INC	2,2
	DSZ	OVCNT
	JMP	OVILP	;NOTE LAST LINK IS 1 BEYOND LINK-TABLE,
	JMP	@OVRET		;HENCE FREEP GETS SET!!
.OVS:	OVSIZ
MSK:	OVSIZ-1	;FOR HASHING
.BASE:	OVBASE
WASI:	0
WAS6:	0
OVCNT:	0
OVRET:	0
HOFST:	HASH-OBASE
;
;	/* OVERFLOW REFERENCE COUNTS */
OVREF:	STA	3,OVRET
	STA	1,WAS6		;=1 IFF RC WAS 6 INCREMENTING
	STA	2,WASI		;=1 IFF INCREMENTING
	MOV	0,1
	LDA	2,MSK
	AND	2,1
	LDA	2,HOFST
	ADD	2,1
	LDA	2,@.BASE	;*HASH ON A
	ADD	1,2,SKP		;I _ OVADR .AND. MSK
FOLLK:	MOV	3,2
	LDA	3,LINK-OBASE,2	;J _ LINK[I]
	SNZ	3,3
	 JMP	MISS
	LDA	1,OVADR-OBASE,3
	SEQ	0,1		;A # OVADR[J]
	 JMP	FOLLK		;*FOLLOW LINKS
;	/*FOUND
	DSZ	WASI
	 JMP	HITDEC
	ISZ	REFCT-OBASE,3		;INC REFCT[J]
	JMP	@OVRET
HITDEC:	DSZ	REFCT-OBASE,3		;DEC	REFCT[J]
	 JMP	@OVRET
;	DEC TO 6 (=0): FREE OV CELL AND DEC REF CT
	LDA	1,LINK-OBASE,3
	STA	1,LINK-OBASE,2	;LINK[I] _ LINK[J]
	LDA	1,FREEP
	STA	1,LINK-OBASE,3	;LINK[J] _ FREE
	STA	3,FREEP		;FREE _ J
	JMP	SKRET
;	/*NOT FOUND
MISS:	DSZ	WASI
	 JMP	@OVRET		;MISS ON DEC = LOST
	DSZ	WAS6
	 JMP	@OVRET		;WAS 7 => MISS ON INC = LOST
;	INC TO 7 (=1): ALLOC OV CELL AND INC REF CT
	LDA	3,FREEP		;J _ FREE
	SNZ	3,3
	 JMP	SKRET		;NO VACANCY
	LDA	1,LINK-OBASE,3
	STA	1,FREEP		;FREE _ LINK[J]
	STA	3,LINK-OBASE,2	;LINK-[I] _ J
	ZER	1,1
	STA	1,LINK-OBASE,3	;LINK[J] _ 0
	STA	0,OVADR-OBASE,3	;OVADR[J] _ A
	ONE	1,1
	STA	1,REFCT-OBASE,3	;REFCT[J] _ 1
SKRET:	LDA	3,OVRET		;SKIP-RETN (DEC/INC REAL REF CT)
	JMP	1,3
;
;
;	/* REFERENCE COUNT TRAP */
REFCC:	LDA	1,MXNUM	; *AC1 GETS SMASHED*
	SNL	0,0	;IF NIL
	SGTU	0,1	;OR SMALL INTEGER
	 JMP	@TRAPX		;THEN QUICK RETN
	STA	3,REF3
	LDA	3,@TRAPPC
	LDA	1,-1,3
	SODD	1,1
	 JMP	INCIT	;EVEN OP IS REFI
	LDA	1,@.RERE
	SNE	1,3	;CHECK FOR RECURSIVE REFD
	 JMP	DECIT	;YEP
	STA	3,RFDX	;NO - SAVE RETN ADDR AND INIT STACK
	STA	2,REF2
	LDA	3,REF3
	STA	3,RFD3
	JSRII	.STAK
	JSR	DECIT
	SKIP
	REFD		;HERE'S THE RECURSIVE REFD
REC:	JSRII	.APOP
	 JMP	.-2
	LDA	2,REF2
	LDA	3,RFD3
	JMP	@RFDX
TRAPX:	526
TRAPPC:	527
.RERE:	RERE
.STAK:	STACKS
.APOP:	POPS
RFD3:	0
RFDX:	0
REF2:	0
REF3:	0
FLD0:	0
;
;	/* DECREMENT REF CT
DECIT:	STA	3,REFX
	JSR	REF	;DISPATCH ON REF CT
	JMP	LFRE	;0 - RELEASE IT
	JMP	RDEC	;1  \
	JMP	RDEC	;2  |
	JMP	RDEC	;3  >- DECREMENT ITS REFCT
	JMP	RDEC	;4  |
	JMP	RDEC	;5  |
	JMP	RDEC	;6  /
	ZER	1,1	;7 - DECREMENT ITS OVERFLOW
	ZER	2,2
	STA	0,FLD0
	LDA	0,PNTR
	JSR	OVREF
	 JMP	@REFX	;STILL > 6
	LDA	0,FLD0
RDEC:	ONE	1,1	;DECR BY 1
	SUB	1,0
	LDA	1,PNTR
	STOR
	JMP	@REFX
;
;	/* INCREMENT REF CT
INCIT:	STA	3,REFX
	STA	2,REF2
	JSR	REF
	JMP	RINC	;0  \
	JMP	RINC	;1  |
	JMP	RINC	;2  >- INCREMENT ITS REFCT
	JMP	RINC	;3  |
	JMP	RINC	;4  |
	JMP	RINC	;5  /
	ONE	1,1,SKP	;6 - CREATE OVERFLOW ENTRY
	ZER	1,1	;7 - INCREMENT THE OVERFLOW
	ONE	2,2
	STA	0,FLD0
	LDA	0,PNTR
	JSR	OVREF
	 JMP	@REFX
	LDA	0,FLD0
RINC:	INC	0,0	;RC=1,2   ..
	LDA	1,PNTR
	STOR
	LDA	2,REF2
	LDA	3,REF3
	JMP	@REFX
;
;	/* DISPATCH ON REF CT
REF:	STA	3,REF5
	STA	0,PNTR	;SAVE PNTR
	MOV	0,3
	DLR3	;******DLR3
	LDA	2,RCMSK
	COM	2,2
	AND	0,2	;MASK REF CT
	LDA	3,REF5
	ADD	2,3	;ADD TO RETN FOR DISPATCH
	JMP	0,3
REF5:	0
;
;	/* STORAGE RECLAIMER AND ALLOCATOR */
;
;
;	F R E E   S T O R A G E   H E R E
;	JMP	LFRE	;POINTER TO OLD BLOCK IN AC0
;
;
;	/* CHECK TYPE FOR SPECIAL CLASSES
LFRE:	LDA	2,numberclass	;ASSUME AC0=CLASS, AC1=FIRST FIELD
	SNE	0,2
	JMP	FNUM
	LDA	2,vectorclass
	SNE	0,2
	JMP	FVECT
	LDA	2,@FPCLS
	SNE	0,2
	JMP	FFLOT
	LDA	2,stringclass
	SNE	0,2
	JMP	FSTRI
;
;	/* INTERROGATE TABLE FOR SIZE
	MOV	0,3
	LDA	1,c7	;instsize
	LDR3
	JSR	@.IVAL
	MOV	0,1
	ONE	0,0
	JMP	FSUBF
;
;	/* SPECIAL CASE: VECTOR
FVECT:	MOV	1,0
	JSR	@.IVAL
	MOV	0,1
	INC	1,1	;ADD ONE FOR LENGTH
	LDA	0,C2
	JMP	FSUBF
;
;	/* FREE SUB-FIELDS - AC0=START, AC1=STOP, AC2=INC
FSUBF:	ONE	2,2
FS2:	STA	2,STEP
	STA	1,SIZE
	STA	0,IFLD
STKLP:	LDA	0,IFLD	;LOOP PUSHES EACH ONTO STACK
	LDA	1,SIZE
	SLE	0,1
	JMP	FREEIT
	LDA	1,PNTR
	ADD	0,1
	LDA	2,STEP	;STEP FIELD POINTER
	ADD	2,0
	STA	0,IFLD
	LOAD
	SNN	0,0
	JMP	STKLP
	LDA	1,MXNUM	;TEST FOR POINTER
	SLEU	0,1
	JSRII	.APUSH	;PUSH INSTANCE[IFLD]
	JMP	STKLP
.APUSH:	PUSHS
STEP:	0
IFLD:	0
REFX:	0
PNTR:	0
;
;	/* SPECIAL CASE: STRING
FSTRI:	MOV	1,0
	JSR	@.IVAL
	INCZR	0,0	;NWORDS= (NCHARS+1)/2
	INC	0,0	;  +1 FOR LEN
	STA	0,SIZE
	JMP	FREEIT
;
;	/* SPECIAL CASE: NUMBER
FNUM:	LDA	0,C2
	JMP	FRE1
FFLOT:	LDA	0,C4
	JMP	FRE1
FPCLS:	FPCLAS	;FLOATING-POINT CLASS
;
;	** FOLLOWING SECTION IS ESSENTIALLY ALGORITHM B
;	FROM KNUTH 2.5, WITH Q=THIS, P0=PNTR, N=SIZE.
;
;	/* SCAN FREE LIST FOR PLACE TO INSERT
FREEIT:	LDA	0,SIZE
	INC	0,0	;ADD 1 TO SIZE FOR TYPE
	INCZR	0,0	;THEN EVEN IT UP
	MOVZL	0,0
FRE1:	STA	0,SIZE
	ISZ	TOPS
	LDA	1,FREE
	STA	1,THIS
FRLP:	LDA	2,THIS
	STA	2,PREV
	STA	1,THIS
	MOV	1,3
	DLR3	;******DLR3
	LDA	2,PNTR
	SGTU	2,0
	JMP	FLINS	;THIS IS THE PLACE
	STA	1,TSIZ
	MOV	0,1,SZR
	JMP	FRLP
	JMP	FLI1
SIZE:	0
;
;	/* INSERT BLOCK IN FREE LIST
;	AC0=THIS.NEXT  AC1=THIS.SIZE  AC2=PNTR <--
FLINS:	STA	1,TSIZ
	LDA	3,SIZE
	ADD	2,3
	SEQ	0,3	;CHECK UPPER BOUNDARY
	JMP	FLI1
;
	MOV	0,3	;MERGE WITH BLOCK ABOVE
	DLR3	;******DLR3
	LDA	2,SIZE
	ADD	2,1
	STA	1,SIZE
;
FLI1:	SNZ	0,0
	DSZ	TOPS	;FLAG TOP OF FREE LIST
	LDA	1,PNTR
	STOR		;LINK TO BLOCK ABOVE
	LDA	1,PNTR
	LDA	2,THIS
	LDA	3,TSIZ
	ADD	3,2
	SEQ	2,1	;CHECK LOWER BOUNDARY
	JMP	FLI2
;
	LDA	0,SIZE	;MERGE WITH BLOCK BELOW
	ADD	3,0
	STA	0,SIZE	; *
	LDA	1,THIS
	INC	1,1
	STOR
	LDA	1,PNTR
	LOAD
	LDA	1,THIS
	STA	1,PNTR	; *
	STOR
	JMP	FLI3
;
NLI2:	LDA	1,THIS	;LINK TO BLOCK BELOW
	STA	1,PREV	; *
	LDA	0,PNTR
	STOR
	LDA	1,PNTR
	INC	1,1
	LDA	0,SIZE
	STOR
;
FLI3:	DSZ	TOPS	;TEST TOP OF FREE LIST
	JMP	@REFX	;NO, DONE
	ISZ	TOPS	;YES, RESET FLAG
;	*  PNTR->TOP BLOCK, PREV->ONE PREV TO THAT  <--
	LDA	1,PNTR
	LDA	0,SIZE
	ADD	1,0
	LDA	2,TLMEM	;TEST IF TOUCHES GREAT BLOCK
	SEQ	0,2
	JMP	@REFX
	STA	1,TLMEM	;YES, SUBSUME IT
	ZER	0,0
	LDA	1,PREV
	STOR		;AND ZERO THE PREV LINK
	JMP	@REFX
;
TSIZ:	0
TOPS:	1
NXT:	0
LALRT:	0
DIFF:	0
PREV:	0
THIS:	0
FREE:	MSAVE+4	;MAYBE WANT THIS IN CAORE?
;
;	/* FREE UNTYPED STORAGE
FUNT:	STA	3,REFX	;AC0=SIZE
	STA	1,PNTR	;AC1=POINTER
	JMP	FRE1
;
;
;	G E T   S T O R A G E   H E R E
;	JSR	LALO	;NWORDS IN AC0, RETURNS WITH PNTR IN AC2
;
;
;	/* SCAN FREE LIST FOR BIG ENOUGH BLOCK
LALO:	STA	3,LALRT
	INCZR	0,0	;EVEN UP BLOCK SIZE
	MOVZL	0,0
	STA	0,SIZE
	LDA	1,FREE	;GET FREE LIST POINTER
LALP:	STA	1,THIS
	MOV	1,3
	DLR3	;******DLR3
	LDA	2,SIZE
	SLT	1,2	;TEST IF BIG ENOUGH
	 JMP	GOTBK
	SNZ	0,0	;TEST IF END OF FREE LIST
	 JMP	LALX
	LDA	2,THIS	;FOLLOW LINK AGAIN
	STA	2,PREV
	MOV	0,1
	JMP	LALP
;
;	/* GOT A BLOCK
GOTBK:	SUB	2,1,SZR	;IF SIZE EXCESS = 0
	JMP	TOOBG
	LDA	1,PREV	;THEN THIS IS OUR BABY
	STOR		;REMOVE IT FROM FREE LIST
	LDA	2,THIS
	JMP	@LALRT
;
;	/* BUT IT'S TOO BIG
TOOBG:	STA	1,DIFF
	MOV	1,0	;THIS.SIZE_REMAINDER
	LDA	1,THIS
	INC	1,1
	STOR
	LDA	2,THIS	;RETURN BOTTOM PART
	LDA	1,DIFF
	ADD	1,2
	JMP	@LALRT
;
;	/* HAVE TO TAKE IT FROM GREAT BLOCK
LALX:	LDA	0,SIZE
	LDA	2,TLMEM
LAL2:	ADD	2,0
	LDA	1,BHMEM
	SGTU	1,0	;TEST END OF MEM
	JMP	JALER
	STA	0,TLMEM
	JMP	@LALRT
;
;	/* ALLOCATE TABLES ON 2**N BOUNDARY
LAL8:	STA	3,L4RET
	INCZR	0,0	;SIZE MUST BE EVEN
	MOVZL	0,0
	STA	0,L4SIZ
	LDA	1,RCMSK	;GRAIN SIZE = ~RCMSK + 1
	INC	1,1
	COM	1,1
	STA	1,GM2	;GRAIN-2
	ADD	1,0
	JSR	LALO	;ALLOCATE N+(GRAIN-2)
	LDA	1,RCMSK
	COM	1,0
	ADD	2,0
	AND	1,0
	STA	0,L4PTR	;BOUNDARY AT (PTR + ~RCMSK).AND.RCMSK
	SUB	2,0
	STA	0,WASTE
	MOV	2,1
	SZE	0,0
	JSR	FUNT	;FREE LOW WASTE (IF ANY)
	LDA	0,GM2
	LDA	1,WASTE
	LDA	2,L4PTR
	SUB	1,0,SNR
	JMP	@L4RET
	LDA	1,L4SIZ
	ADD	2,1
	JSR	FUNT	;FREE HIGH WASTE (IF ANY)
	LDA	2,L4PTR
	JMP	@L4RET
L4RET:	0
L4PTR:	0
L4SIZ:	0
WASTE:	0
GM2:	0
;
;
;	/* SINGLE STACK DOWN FROM BHMEM
STACK:	STA	3,STKRT	;INIT THE STACK
	LDA	3,BHMEM
	STA	3,STKPT
	JMP	@STKRT
;
PUSH:	STA	3,STKRT	;PUSH AC0 ONTO STACK
	DSZ	STKPT
	LDA	1,STKPT
	LDA	2,TLMEM
	SGTU	1,2
	 JMP	JALER
	STOR
	JMP	@STKRT
;
POP:	LDA	1,STKPT	;POP STACK INTO AC0
	LDA	2,BHMEM
	SNE	2,1
	 JMP	1,3	;SKIP-RETURN IF EMPTY
	STA	3,STKRT	
	LOAD		;ELSE AC0 _ TOP GUY
	ISZ	STKPT
	JMP	@STKRT
STKRT:	0
STKPT:	0
;
JALER:	JSR	@.QERR
	.TXT	"I've run out of memeory."
	.END
