;//	SMALLOC.SR
;//	ALLOCATE/DEALLOCATE DISK PAGES. COMPUTE ALTO DISK
;//	AND VIRTUAL ADDRESSES. SHORTEN FILES. LOAD & SAVE
;//	AND DIRECT DISK ACCESS.

	.TITL	SMALLOC

	.GETNOLIST	"SMALL.OPS"
	.GETNOLIST	"SMALL.SYMS"
	.GETNOLIST	"SMFILES.OPS"
	.GETNOLIST	"SMFILES.SYMS"

	.SREL

ALLOC:	ALLOCC
DSKADR:	DSKADC
DSKSEC:	DSKVAC
SHORTN:	SHORTC
DALLOC:	DALOCC
PAGIO:	PAGIOC
GBDSK:	GBDSKC

	.NREL
 
;//	ALLOCATE FIRST FREE PAGE ('NEAR' AN ALTO DISK ADDRESS)
;//	 NOT QUITE SAME AS GENE'S ALGORITHM SINCE WE MAY SOMETIMES
;//	 USE AN EARLIER PAGE WHEN HE WOULD HAVE PICKED A LATER ONE. 

;//	 AC1	ALTO DISK ADDRESS
;//	 AC2	BIT TABLE FILE INSTANCE
;//	RETURNS+1	IF UNSUCCESSFUL
;//	RETURNS+2	IF SUCCESSFUL
;//	 AC1	ALTO DISK ADR OF PAGE ALLOCATED
 
A3:	0
C20:	20
 
ALLOF:	STA	3,A3
	ONE	3,3
	STA	3,WWRAP	;// FOR TABLE WRAPAROUND
	JSR	DSKVAC	;// CONVERT ALTO DISK ADR TO VIRTUAL ADR
	AND	0,1	;// START AT WORD BOUNDARY. PAGE INDEX
FRE:	STA	1,INDEX	;// REENTER HERE AFTER WRAPAROUND
	MOVZR	1,0
	MOVZR	0,0
	MOVZR	0,0	;// INDEX/8 IS CHAR AT WORD BOUNDARY
	ONE	1,1	;// STARTING FROM PAGE 1
	JSRII	.SRBYT	;// SET FILE CHARACTER PTR IN BITTABLE
	 JMP	@A3
NW:	JSRII	.GFWD	;// GET A WORD FROM BIT TABLE
	LDA	1,INDEX
	SNL	0,0	;// ALL ONES (NO FREE PAGES)?
	 JMP	FOUND
	LDA	0,C20	;// SKIP 16 PAGES (1 WORD IN BITTABLE)
	ADD	0,1
	STA	1,INDEX
	JMP	NW
 
FWRAP:	ZER	1,1	;// NEW INDEX. ALSO ZERO ADR ON FAILURE
	DSZ	WWRAP
	 JMP	@A3	;// WE'VE ALREADY WRAPPED. DON'T SKIP.
	JMP	FRE

NBIT:	INC	1,1,SKP	;// NEXT PAGE (INDEX)
FOUND:	 SUBZR	3,3,SKP	;// 100000 (0 COM BY OVERFLOW, RSH 1)
	  MOVZR	3,3	;// NEXT BIT
	AND#	0,3,SZR	;// IS THIS POSITION 0?
	 JMP	NBIT
	ADD	3,0	;// MARK PAGE BY SETTING BIT IN WORD
	LDA	3,BTSIZ
	SLT	1,3	;// PAST END OF BITTABLE?
	 JMP	FWRAP
	STA	1,INDEX
	ADCZL	1,1	;// -2. REPOSITION 1 WORD
	JSRII	.RFPTR
	JSRII	.PFWD	;// REWRITE WORD (STILL IN AC0!)
	LDA	1,INDEX
	SKIP

DSKADC:	 STA	3,A3	;// ENTRY POINT -- AC1 IS VIRTUAL ADR
	ZER	0,0	;// CONVERT VIRTUAL TO ALTO DISK ADR
	LDA	2,NSECT	;// (SEE FORMAT BELOW). SOFTWARE DIVIDE..
	JSR	@.DIV	;// AC1/AC2. QUOT IN AC1, REM IN AC0.
	LDA	2,NTRAC
	SLT	1,2	;// TRACK*2+HEAD < NTRAC?
	 JMP	@A3	;// ILLEGAL TRACK
	MOVZS	0,3	;// SECTOR _ VA MOD 12
	ADDZL	3,3	;// SECTOR IS NOW IN BITS 0-5
	ADDZL	3,1	;// SECTOR, TRACK, HEAD, DISK (_0)
	MOVZL	1,1	;// BIT 15 _ 0
	LDA	3,A3
	JMP	1,3
 
;//	FORMAT OF ALTO DISK ADDRESS
;//	BITS
;//	0-3	SECTOR
;//	4-12	TRACK
;//	13	HEAD
;//	14	DISK
;//	15	RESTORE
 
C17:	17	;// SECTOR MASKC777:	777	;// TRACK MASK
INDEX:	0
WWRAP:	0
.GFWD:	GFWD
.PFWD:	PFWD
.RFPTR:	RFPTR
.SRBYT:	SRBYTE
 
;//	INVERSE OF DSKADR -- COMPUTES VIRTUAL DISK ADDRESS
;//	 AC1 IS ALTO DISK ADDRESS
;//	RETURNS+1, AC1 IS VIRTUAL ADR = (TRACK*2+HEAD)*12+SECTOR
 
DSKVAC:	STA	3,F3  
	MOVZR	1,1
	MOVZR	1,1	;// IGNORE DISK BIT
	MOVZR	1,1	;// CARRY_HEAD
	LDA	3,C777	;// TRACK MASK=777
	ANDL	1,3	;// AC3 _ TRACK*2+HEAD
	MOVZL	3,0
	ADDZL	0,3
	MOVZL	3,3	;// AC3 _ AC3*12
	MOVZR	1,1
	MOVZS	1,1
	LDA	0,C17	;// SECTOR MASK=17
	AND	0,1	;// AC1 _ SECTOR
	ADD	3,1	;// AC1 HAS TOTAL SECTORS
	COM	0,0	;// AC0 HAS 177760
	JMP	@F3 	;// AC2 IS UNCHANGED 
 
;//	ALLOCATE A FREE DISK PAGE. MARK BIT IN BITTABLE (ALLOF), BUT
;//	IF PAGE SERIAL NUMBER IS NOT "FREE" I.E. -1, THEN ALLOCATE
;//	ANOTHER PAGE.  AC1 IS ALWAYS AN ALTO DISK ADR
 
ALLOCC:	STA	3,G3
ALOC1:	LDA	2,BINST	;// SET PREVIOUSLY BY GBDSK
	JSR	ALLOF	;// ALLOCATE FIRST PAGE
	 JMP	@G3	;// DISK ERROR OR FULL
	LDA	0,@.DBUF	;// CORE BUFFER
	LDA	2,.CRR	;// READ LABEL AND DATA
	JSRII	.DSKIO	;// ADDRESS IS IN AC1 FROM ALLOF
	DISK+BT-.	;// DISK NUMBER, FOLLOWED BY LABEL
G3:	0		;// STARTING PAGE RELEVANT IF LABEL CHECKING
	1		;// NUMBER OF PAGES
.DBUF:	DSKBUF		;// CORE INC -- IRRELEVANT FOR 1 PAGE
	 JMP	ALOC1	;// PROBABLY CHECKSUM ERROR. LEAVE
			;// PAGE MARKED AND TRY AGAIN.
	ISZ	SN1+BT	;// SN1=SN2=-1?(FREE PAGE)
	 JMP	ALOC1		;// ALLOCATE ANOTHER PAGE
	ISZ	SN2+BT
	 JMP	ALOC1
	LDA	3,G3
	JMP	1,3
 
BTAB:	.BLK	LABSIZ+1	;// DISK NUMBER, LABEL BLOCK
BT	= BTAB-DISK	;// INCOMPLETE INSTANCE OFFSETTING

.CRW:	CRW	;// DISK COMMANDS
.CRR:	CRR
.CWW:	CWW 
BINST:	0
F3:	0

BTSIZ:	.-.	;// NUMBER OF DISK PAGES (MAX VIRTUAL ADDRESS+1)
NTRAC:	.-.	;// NUMBER OF DISK TRACKS*2
NSECT:	14	;// NUMBER OF DISK SECTORS (12 DECIMAL)
 
;//	SHORTEN FILE
;//	 AC0 IS NUMBER OF CHARS ON LAST PAGE
;//	 AC1 IS NUMBER OF LAST PAGE
;//	 AC2 IS FILE INSTANCE
 
SHORTC:	STA	3,G3
	JSRII	.SRBYT	;// GO TO 'LAST' PAGE OF FILE. SIDE
	 JMP	@G3	;// EFFECT OF CALLING GBDSK.
	MOV	1,0	;// NUMCH _ BYTEC (RETURNED BY SRBYTE)
	JSR	@.SNST
	NUMCH
	JSR	@.LNST
	NEXTP
	STA	0,DCUR	;// SAVE NEXTP FOR DEALLOCATION
	ZER	0,0	;// NEXTP_0
	JSR	@.SNST
	NEXTP
	ONE	0,0	;// LABEL BLOCK IS NOW DIRTY
	JSR	@.SNST
	DIRTY
SDALC:	LDA	1,DCUR	;// DEALLOCATE PAGE AT (AND AFTER)
	JMP	DEAGN	;// THIS ADDRESS

;//	DEALLOCATE DISK PAGES
;//	 AC1 IS BEGINNING ADR OF PAGE CHAIN
 
DALOCC:	STA	3,G3
	STA	1,DCUR
DEAGN:	LDA	2,BINST	;// SET PREVIOUSLY BY GBDSK
	SNZ	1,1	;// END OF CHAIN?
	 JMP	DLDON	;// REWIND (AND WRITE) BITTABLE
	JSR	DSKVAC	;// CONVERT DISK ADR TO VIRTUAL
	STA	1,INDEX
	ANDZR	1,0	;// POINT TO BEGINNING OF WORD
	MOVZR	0,0	;// /8 TO GET WORD BOUNDARY (SEE ALLOF)
	MOVZR	0,0
	ONE	1,1	;// STARTING FROM PAGE 1
	JSRII	.SRBYT	;// POSITION BITTABLE
	 JMP	@G3

	JSRII	.GFWD	;// GET THE WORD
	LDA	3,C17
	LDA	1,INDEX
	AND	3,1	;// BIT POSITION
	ADCZR	3,3	;// 77777 (-1, 0 CARRY RSH 1)
	NEG	1,1,SNR	;// TO COUNT UP
	 JMP	.+4
	MOVOR	3,3	;// SHIFT BIT MASK, FILLING 1'S ON LEFT
	INC	1,1,SZR	;// CORRECT POSITION?
	 JMP	.-2
	AND	3,0	;// TURN OFF BIT IN WORD
	ADCZL	1,1	;// -2. REPOSITION 1 WORD
	STA	1,WWRAP	;// ALSO FLAG FOR READ/WRITE BELOW
	JSRII	.RFPTR
	JSRII	.PFWD	;// PUT BACK WORD (STILL IN AC0)

	LDA	1,DCUR
	LDA	2,.CRR	;// READ LABEL AND DATA
DPAGE:	LDA	0,@.DBUF
	JSRII	.DSKIO
	DISK+BT-.
DCUR:	0		;// IRREL IF NOT CHECKING LABEL
	1
.SREW:	SREW		;// IRREL FOR 1 PAGE
	 JMP	@G3
	ISZ	WWRAP	;// SECOND TIME THRU (FINISHED WRITING)?
	 ZER	0,0,SKP	;// NO. WRITE NOW.
	JMP	SDALC
	LDA	3,NEXTP+BT	;// SAVE NEXT ADDRESS IN CHAIN
	STA	3,DCUR
	STA	0,NEXTP+BT	;// UNCHAIN PAGES TO PREVENT
	NIL	0,0		;// POSSIBLE DISASTER.
	STA	0,SN1+BT		;// MARK PAGE AS FREE
	STA	0,SN2+BT
	LDA	2,.CWW		;// WRITE LABEL BLOCK
	JMP	DPAGE		;// AC1 STILL HAS ADR
DLDON:	JSRII	.SREW
	 JMP	@G3
	LDA	3,G3
	JMP	1,3
 
.DSKIO:	DSKIO

;//	GET BITTABLE INSTANCE AND DISK NUMBER
;//	 AC2 IS FILE INSTANCE, AC1 PRESERVED
;//	 RETURNS+1 WITH AC0 DISK NUMBER, AC2 BITTABLE INSTANCE
 
GBDSKC:	STA	3,F3	;// ALSO SETS BINST AND DISK+BT FOR
	STA	1,DISK+BT	;// ALLOC, DALLOC
	INC	2,1
	LOAD			;// DIRECTORY INSTANCE
	STA	0,DISK+MT	;// ...SAVE
	INC	0,1
	INC	1,1
	LOAD		;// BITTABLE INSTANCE
	STA	0,BINST
	LDA	0,DISK+MT	;// DIRECTORY INSTANCE
 
GLP:	INC	0,1
	LOAD		;// DIRECTORY OF DIRECTORY
	JSR	@.ISIT	;// IS IT A NUMBER, I.E. DISK NUMBER?
	NCLAS
	 JMP	GLP
	JSR	@.IVAL	; AC0 NOW IS CURDIR 0-3 (SEE TABLE BELOW)	ZER	3,3	MOVZR	0,0,SZC	;// 'COMPLEMENT DISK NUMBER' (1 OR 3)	 ONE	3,3	LDA	1,BT31	LDA	2,TR31	MOVZR	0,0,SNC	;// RANGE OF ADDRESSING	 JMP	.+3	MOVZL	1,1	;// 2 OR 4 ....TWICE AS MANY PAGES, TRACKS	MOVZL	2,2	STA	1,BTSIZ		;// FOR ALLOCATOR	STA	2,NTRAC	;// FOR DISK ADDRESS MAKER	LDA	1,DISK+BT	;// RESTORE ORIGINAL AC1	MOV	3,0		;// THIS BIT (1 WHEN CURDIR IS ODD);//  SIGNALS DSKIO TO MAKE THE DISK COMMAND COMPLEMENT THE DISK;//  BIT, THEREBY ACCESSING ANOTHER DRIVE WITH '0' ADDRESSES	STA	0,DISK+BT	STA	0,DISK+MT 
	LDA	2,BINST		;// BITTABLE INSTANCE
	JMP	@F3
;// MULTIPLE DISKS, BITTABLES 25 APR 75;//     'CURDIR'    DISK #     COMP     PHYS       WHICH     DISK;//       	              IN ADR     DISK #   DRIVE       'HALF'     MODEL;//	0	0	no	0	1	31,44;//	1	0	yes	1	1	31,44;//	2	0	no	0	2 	44;//	3	0	yes	1	2	44	.RDX	10BT31:	4872		;// NUMBER OF PAGES ON MODEL 31 TR31:	406		;// NUMBER OF MODEL 31 DISK TRACKS*2	.RDX	8LSET:	STA	3,X3	;// AC2 HAS FILE INSTANCE
	SNL	0,0	;// -1? 
	 JMP	.+3
	JSR	@.LNST	;// GET CURRENT ADDRESS
	CURADR
	STA	0,DCUR	;// STASH HERE
	JSRII	.IRCOP	;// COPY LABEL BLOCK
	SN2		;// NEXTP THRU SN2
	1+SN2+MT-.
	-LABSIZ
	JSR	GBDSKC	;// GET DISK NUMBER, BITTABLE INSTANCE
	JMP	@X3

;//	DO DIRECT DISK COMMANDS FROM SMALLTALK

PAGIOC:	STA	3,M3
	STA	2,FINST
	
	JSR	FICH	;// FETCH INTEGER FROM MESSAGE
	STA	0,DCOR	;// CORE ADDRESS
	JSR	FICH
	LDA	2,FINST
	JSR	LSET	;// GET DSKADR, LABEL BLOCK, DISK NUMBER
	JSR	FICH
	STA	0,DCOM	;// DISK COMMAND
	JSR	FICH
	STA	0,PSPAG	;// STARTING PAGE RELEVANT IF CHECKING LABEL
	JSR	FICH
	STA	0,PNPAG	;// NUMBER OF PAGES
	JSR	FICH
	STA	0,PCOR	;// CORE INCREMENT

	LDA	0,DCOR
	SNL	0,0	;// -1 MEANS COPY SADR TO DSKBUF
	 JMP	PDOIT
	LDA	2,FINST
	LDA	1,C3
	ADD	2,1
	LOAD		;// STRING INSTANCE
	INC	0,0
	INC	0,2	;// STRING ADDRESS
	STA	2,PSADR	;// FOR COPY BACK
	JSRII	.SBCOP	;// COPY STRING TO STANDARD BUFFER
PDOIT:	LDA	1,DCUR	;// AC0 HAS APPROPRIATE CORE ADDRESS
	LDA	2,DCOM
	JSRII	.DSKRW
	DISK+MT-.
PSPAG:	0
PNPAG:	0
PCOR:	0
	 SKIP	;// ERROR
	  ZER	2,2
	STA	2,STATUS+MT	;// (I.E. SAME AS "DISK")

	LDA	2,FINST
	LDA	3,PNPAG
	SNE	0,3	;// ANY PAGES PROCESSED?
	 JMP	.+4	;// NO PAGE CHANGE -- DON'T UPDATE CURADR
	MOV	1,0
	JSR	@.SNST	;// UPDATE CURADR
	CURADR
 
	JSRII	.RICOP	;// COPY LABEL BACK
	SN2		;// STATUS THRU SN2
	1+SN2+MT-.
	-LABSIZ-1
	LDA	0,DCOR
	SNL	0,0
	 JMP	PRET
	LDA	2,PSADR
	JSRII	.BSCOP	;// COPY BUFFER BACK TO SADR
PRET:	LDA	0,STATUS+MT
	SZE	0,0
	 JMP	@M3	;// ERROR
	LDA	3,M3
	JMP	1,3

MTAB:	.BLK	LABSIZ+1	;// DISK NUMBER AND LABEL BLOCK
MT	= MTAB-DISK
DCOM:	0
M3:	0
FINST:	0
DCOR:	0
.IRCOP:	IRCOP
.RICOP:	RICOP
.BSCOP:	BSCOP
.SBCOP:	SBCOP
.DSKRW:	DSKRW
.CCR:	CCR
.CCW:	CCW
PSADR:	0
X3:	0
 
FICH:	STA	3,X3
	JSR	@.FECH
	JSR	@.IVAL
	JMP	@X3

	.END
 