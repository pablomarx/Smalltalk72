	.TITL	CODE
	.GETNOLIST	"SMALL.SYMS"
	.GETNOLIST	"SMALL.OPS"
	.GETNOLIST	"SMALL.PARMS"
;	***NOTE ALL STATICS IN THIS MODULE MUST BE REFERRED TO 
;	IN PAGE1.SR, SO THAT THEY CAN BE RELOCATED WHEN CODE.SR
;	GETS MOVED***
	.ZREL	;STATICS
.FALS:	RFALSE
	.SREL
EQ1:	EQ1C
MKINS:	MKINSC
ISNEW:	ISNEWC
FET1:	FET1C
NUM1:	NUM1C
AGAIN:	AGAINC
QUOT1:	QUOT1C
EMPT1:	EMPT1C
PUT1:	PUT1C
ATOM1:	ATOM1C
TO1:	TO1C
MEM1:	MEM1C
GET1:	GET1C
MAT1:	MAT1C
APRET:	APRETC
RPT1:	RPT1C
NULL:	NULLC
DONE1:	DONE1C
RSELF:	RSELFC
MOD:	MODC
RPTMK:	RPTX
QFET:	QFETC
PEEKR:	PEEKC
FIRSTOFCODE:	SIZEC

	.NREL
SIZEC:	LASTOFCODE-.
;
;//
;//	/* REPEAT */
RPT1C:	LDAF	ARG0
	JSRII	.EVTK		;//EVAL ARG
RPTX:	JMP	RPT1C		;//REPETITIVELY
.EVTK:	EVTKS
;//
;//	/* AGAIN */
AGAINC:	JSR	POPRP		;//RETURN UP TO REPEAT
	JMP	0,2		;//AND RETURN TO (AC2) (REPEAT OR FOR)
;//
;//	/* DONE */
DONE1C:	LDAF	ARG0
	JSR	@.SVAL
	JSR	POPRP		;//RETURN UP TO REPEAT
	JMP	@.ERET		;//AND RETURN HIM TOO
;//
POPRP:	STA	3,RTRET		;//POP UP TO ENCLOSING REPEAT
POPR1:	LDAF	MODE
	LDA	2,@.RPTMK		;//CHECK FOR REPEAT MARK
	SNE	0,2
	JMP	@RTRET		;//YES, RETURN
	LDA	2,@.FORMK		;//SIMILARLY FOR 'FOR'
	SNE	0,2
	JMP	@RTRET
	JSR	@.SRET		;//RETURN THIS PROCESS
	JMP	PERR1		;//(HIT TOP LEV)
	JMP	POPR1		;//AND LOOP
PERR1:	JSR	@.QERR
	.TXT	"I couldn't find an enclosing repeat"
.RPTMK:	RPTMK
.FORMK:	FORMK
RTRET:	0
;//
;//	/* NUMBER CLASS */
NUM1C:	LDAF	INST
	SNN	0,0
	JMP	@.EVAL
	LDA	0,.QPER
	JSR	@.PEEK
	JMP	RSELFC
	JSR	@.INDX		;//AND SEARCH KNOWN OPERATORS
TAB1:	X5-.-1
	QMPER	;// &
	QPLUS	;// +
	QSTAR	;// *
	QHYPH	;// -
	QSLAS	;// /
CMA:	QEQ	;// =
	QNEQ	;// #
	QLESS	;// <
	QLEQ	;// <=
	QGEQ	;// >=
CMB:	QGRTR	;// >
	QMOD	;// MOD
X5:	SNN	2,2
	JMP	@.EVAL		;//OUT TO SMALLTK IF NOT KNOWN
	STA	2,OPIX
	SZE	2,2
	JMP	FVAL1
	JSR	@.AMPC		;//PEEK AGAIN
	LDA	0,.QPER	;//AFTER & FOR LOGICAL OPS
	JSR	@.PEEK
	JMP	@.ERR
	JSR	@.INDX
	X8-.-1
	QSLAS	;// &/
	QPLUS	;// &+
	QSTAR	;// &*
	QHYPH	;// &-
X8:	SNN	2,2
CHOKE:	JMP	@.ERR
	LDA	0,TAB1	;//ADD TO MAX INDEX
	ADD	0,2
	STA	2,OPIX
FVAL1:	JSR	@.AMPC
	LDA	0,OPIX
	JSR	@.INTN
	STAF	ARG0
	JSR	@.FECH		;//FETCH OPERAND
	LDAF	ARG0
	JSR	@.IVAL
	STA	0,OPIX
	LDA	0,VALUE
	LDA	1,EMPTY
	SNE	0,1
	JSR	CKCMP
	JSR	@.ISIT
	NCLAS
	SKIP
	JMP	STV
	JSR	@.ISIT	;//NOT INTEGER, CHECK FLOATING
	FPCLAS
	JMP	EQT	;//NOPE
	JSR	@.IVAL	;//YUP, GET IPART
	MOV	0,1
STV:	STA	1,VAL1	;//ELSE STORE VALUE
	LDAF	INST
	JSR	@.IVAL	;//AND AC0 _ OWN VALUE
	LDA	2,OPIX
	LDA	1,VAL1	;//AC1 _ ARG VALUE
	JSR	.+1	;//SET AC3
	ADD	2,3
	JMP	2,3	;//DISPATCH ON OPERATOR, ARGS IN AC0,1
	JMP	CHOKE
	JMP	NUM20	;//+
	JMP	NUM21	;//*
	JMP	NUM22	;//-
	JMP	NUM23	;///
	JMP	NUM25	;//=
	JMP	NUM25A	;//#
	JMP	NUM24	;//<
	JMP	NUM24A	;//<=
	JMP	NUM26A	;//>=
	JMP	NUM26	;//>
	JMP	NUM27	;//MOD
	JMP	NUM30	;//&/ SHIFT
	JMP	NUM31	;//&+ OR
	JMP	NUM32	;//&* AND
	JMP	NUM33	;//&- XOR
X2:	JSR	@.ERR	;//OUT OF RANGE
;
CKCMP:	LDA	1,CM1	;CHECK FOR COMPARISON OPERATORS
	LDA	2,OPIX	;FOR WHICH FALSE DOMINATES TO ALLOW
	SGE	2,1	; FORMS LIKE  4<X<7
	JMP	0,3
	LDA	1,CM2
	SLE	2,1
	JMP	0,3
	JMP	@.FALS	;YES - RETURN FALSE
CM1:	CMA-TAB1-1
CM2:	CMB-TAB1-1
;
EQT:	LDA	2,OPIX	;// NON-NUMERIC COMPAREE:
	LDA	1,CM1
	SNE	1,2
	 JMP	@.FALS	;// SO = RETURNS FALSE
	SUBOR#	1,2,SNR
	 JMP	RSELFC	;// AND # RETURNS SELF
	LDA	0,VALUE
	JSR	@.IVAL	;// ELSE ERR OUT
	JSR	@.ERR
;
INTNR:	JSR	@.INTN		;//INTERN RESULT IN AC0
	JSR	@.SVLI
	JMP	@.ERET		;//POP AND RETURN
RS1:	LDA	0,.QPER
	JSR	@.PEEK		;//IF END OF MESSAGE
	JMP	@.EVAL		;//THEN RETURN # @INSTANCE
	SNL	0,0
	JMP	@.EVAL		;//ELSE PROCEED
RSELFC:	LDAF	INST		;//RETURN SELF (INSTANCE)    
	JSR	@.SVAL		;//INTO VALUE W/O REFI
	JMP	@.ERET		;//POP AND RETURN
OPIX:	0
;//
NUM20:	ADD	1,0		;//ADDITION
	JMP	INTNR
NUM21:	MOV	0,2		;//MULTIPLICATION
	ZER	0,0
	JSR	@.MUL
	MOV	1,0
	JMP	INTNR
NUM22:	SUB	1,0		;//SUBTRACTION
	JMP	INTNR
NUM23:	MOV	1,2		;//DIVISION
	MOV	0,1
	SP	1,1
	NEG	1,1
	SP	2,2
	NEG	2,2,SKP
	NEG	0,0	;//AC0 SIGN IS - SIGN OF RESULT
	STA	0,SIGN
	ZER	0,0
	JSR	@.DIV
	MOV	1,0
	LDA	1,SIGN
	SN	1,1
	NEG	0,0
	JMP	INTNR		;//THANK YOU BARBARA
SIGN:	0
NUM27:	MOV	1,2		;//MOD
	MOV	0,1
	JSR	MODC
	JMP	INTNR
;	/* AC0 _ AC1 MOD AC2
MODC:	STA	3,MODX
	STA	1,SIGN	;//REMEMBER SIGN OF INPUT
	SP	1,1
	NEG	1,1
	SP	2,2	;//FORCE MODULUS +VE
	NEG	2,2
	ZER	0,0
	JSR	@.DIV
	LDA	1,SIGN
	SZE	0,0
	SN	1,1	;//IF INPUT WAS NEG
	JMP	@MODX
	SUB	0,2	;//THEN RETURN MODULUS-RESIDUAL
	MOV	2,0
	JMP	@MODX
MODX:	0
NUM25A:	SNE	0,1		;//NOT EQUAL
	JMP	@.FALS
	JMP	RSELFC
NUM25:	SEQ	0,1		;//EQUAL
	JMP	@.FALS
	JMP	RSELFC
;
NUM24A:	SNE	0,1		;//LESS/EQUAL
	JMP	RSELFC
NUM24:	MOV	0,2		;//LESS-THAN
	MOV	1,0
	MOV	2,1
	JMP	NUM26
;
NUM26A:	SNE	0,1		;//GREATER/EQUAL
	JMP	RSELFC
NUM26:	SUBZR	2,2		;//GREATER THAN
	AND	1,2
	ADDL	0,2	;//(CODE WHICH WORKS FOR -30000<30000)
	ADC#	1,0,SNC
	JMP	RFALSE
	JMP	RSELFC
VAL1:	0
;//
;//	/* ACTIVE RETURN OF FALSE */
RFALSE:	LDA	0,.QUEST	;//PEEK FOR "?"
	JSR	@.PEEK
	JMP	REM1
	LDA	0,EMPTY		;//RETURN EMPTY ACTIVE
	JMP	ARET
REM1:	JSR	@.AMPC	;//SKIP OVER ?-CLAUSE
	LDA	0,EMPTY		;//AND RETURN EMPTY PASSIVE
	JSR	@.SVAL
	JMP	@.ERET
;//
;//	/* LOGICAL OPS
NUM30:	ONE	2,2	;//&/ SHIFT
	JMP	TST
LOOP:	SN	1,1
	MOVZL	0,0,SKP
	MOVZR	0,0,SKP
	SUB	2,1,SKP
	INC	1,1,SNR
TST:	SZE	1,1
	JMP	LOOP
	JMP	INTNR
NUM31:	COM	1,1	;//&+ OR
	AND	1,0
	ADC	1,0
	JMP	INTNR
NUM32:	AND	1,0	;//&* AND
	JMP	INTNR
NUM33:	COM	0,2	;//&- XOR
	COM	1,3
	AND	2,1
	AND	3,0
	ADD	1,0
	JMP	INTNR
VAL0:	0
;//
;//	/* QUOTE */
QUOT1C:	JSR	@.AMPC		;//PICK UP TOKEN
ARET:	JSR	@.SVAL
	JMP	@.ARET	;//AND APPLY IT
;//
;//	/* ATOM PROCESS */
ATOM1C:	LDAF	INST
	SNN	0,0		;ISNEW?
	 JMP	NEWAT
	LDA	0,.QLARO
	JSR	@.PEEK		;//TEST FOR "_"
	JMP	ATM2
	LDA	1,.QCHAR		;//TEST FOR "chars"
	SNE	0,1
	JMP	ATM3
	LDA	1,.QEVAL
	SNE	0,1
	JMP	ATM4
	LDA	1,.QEQ
	SNE	0,1
	JMP	ATM5
	JMP	RS1
ATM2:	JSR	@.FECH		;//"_", FETCH VALUE
	LDAF	INST
	STA	0,VAL1
	LDAF	GLOB		;//BIND IT IN GLOBAL
	MOV	0,2
	LDA	1,VAL1		;//TO THIS ATOM
	LDA	0,VALUE
	JSR	@.PUT
	JMP	@.ERET
ATM3:	JSR	@.AMPC
	LDAF	INST		;//"chars" - LOOK UP PNAME
	MOV	0,1
	LOAD
	JMP	ARET		;//AND RETURN ACTIVE
ATM4:	JSR	@.AMPC		;//"#" - LOOK UP BINDING
	LDAF	INST
	STA	0,VAL1
	LDAF	GLOB
	MOV	0,2
	LDA	1,VAL1
	JSR	@.FIND
	NOP
	JMP	ARET
ATM5:	JSR	@.AMPC
	JSR	@.FECH
	LDAF	INST
	LDA	1,VALUE
	SEQ	0,1
	JMP	@.FALS
	JMP	@.ERET
NEWAT:	JSR	@.FECH		;FETCH THE STRING
	JSRII	.MKAT
	JSR	@.SVLI		;AND INTERN IT FOR RESULT
	JMP	@.ARET
.MKAT:	MKATOM
.QEQ:	QEQ	;//HASH OF "="
.QEVAL:	QEVAL	;//HASH OF "eval"
.QCHAR:	QCHAR	;//HASH OF "chars"
;//
;//	/* PUT */
PUT1C:	ONE	1,1		;//GET NAME
	JSR	@.LARG
	STA	0,VAL1
	LDA	1,C2		;//GET VALUE
	JSR	@.LARG
	STA	0,VAL0
	LDAF	ARG0		;//GET TABLE
	MOV	0,2
	LDA	1,VAL1
	LDA	0,VAL0
	JSR	@.SPUT
	JMP	@.ERET
;//
;//	/* EMPTY CLASS OPS */
EMPT1C:	LDAF	INST		;//SET INST IN CASE CALLED
	SNL	0,0
	JMP	MT1
	LDA	0,EMPTY
	JSR	@.REFI
	STAF	INST
MT1:	JSR	@.LMPC		;//PEEK AT MESS.PC.1
	LDA	1,.QPER
	SNL	0,0
	SNE	0,1		;//CHECK FOR VOID MESSAGE
	JMP	@.RSELF
	MOV	0,1
	JSR	@.NEXT
	JSR	@.INDX		;//TEST FOR RECOGNIZED OPERATORS
	X4-.-1
	QUEST	;// ?
	QOR	;// or
	QAND	;// and
	QGRTR	;// >
	QEQ	;// =
	QLESS	;// <
X4:	SNN	2,2
	JMP	@.EVAL		;//NO, OUT TO SMALLTK
	SNZ	2,2
	JMP	EMPT2
	MOV	2,0		;//YES, SAVE INDEX IN ARG0
	STAF	ARG0
	JSR	@.AMPC
	JSR	@.FECH		;//EVAL NEXT INPUT
	LDAF	ARG0
	STA	0,EXPT	;//GET OP FROM ARG0
	NIL	0,0
	STAF	ARG0	;//ARG0 WASN'T VALID INST
	DSZ	EXPT	;//TEST IF OP WAS "or"
	JSRII	.RSELF
	JMP	@.ERET		;//YES, RETURN WITH ARG'S VAL
EMPT2:	JSR	@.AMPC		;//ARG IS -IMPLIES- (?)
	JSR	@.AMPC
	JSRII	.RSELF
.RSELF:	RSELF
;//
ARGV:	;//RETURN (INTEGER) VALUE OF FIRST ARG IN AC0
	STA	3,AVRET
	LDAF	ARG0
	LDA	3,AVRET
	JMP	@.IVAL
AVRET:	0
EXPT:	0
;//
;//	/* MEM - CORE VALUE */
MEM1C:	LDA	0,.QLARO	;//PEEK FOR "_"
	JSR	@.PEEK
	JMP	MEM1A	;//FOUND "_"
	JSR	ARGV	;//NO, GET VALUE OF ARG
	MOV	0,2
	LDA	0,0,2	;//LOAD FROM THAT ADDRESS
	JSR	@.INTN	;//INTERN CONTENTS
	JSR	@.SVLI
	JMP	@.ERET
MEM1A:	JSR	@.FECH	;//FOUND "_", GET VALUE
	JSR	ARGV	;//GET ADDRESS
	STA	0,EXPT
	LDA	0,VALUE
	JSR	@.ISIT
	NCLAS
	SKIP
	JMP	STO	;//USE VALUE IF NUMBER
	LDA	1,@.MEMBI	;//OTHERWISE CORE ADDR !! OF ARG
	ADD	0,1
STO:	LDA	2,EXPT
	STA	1,0,2	;//STORE IT (GOOD LUCK!)
	JSR	@.ERET
.MEMBI:	MEMBITS
;//
;//	/* GET */
GET1C:	LDAF	ARG0
	JSR	@.ISIT
	MASTER	;//MAKE SURE ARG0 IS A TABLE
	JMP	RNIL
	STA	0,EXPT
	ONE	1,1
	JSR	@.LARG
	MOV	0,1
	LDA	2,EXPT
	JSR	@.SGET
RNIL:	NIL	0,0	;//NOT FOUND
	JSR	@.SVAL
	JMP 	@.ERET
;//
;//	/* NESTED FETCHES */
FET1C:	LDAF	GLOB	;//SELF_GLOBAL TEMPORARILY
	LDA	1,SELF
	STA	1,TSELF
	JSR	@.SSLF
	JSR	@.AMPC	;//TO FETCH GLOB.MESS.PC.1
	STA	0,TOKEN
	LDAF	MESS	;//AND GET POINTERS FOR EVAL
	STA	0,MESSX
	LDAF	GLOB
	STA	0,GLOBX
	LDA	0,TSELF
	JSR	@.SSLF	;//RESTORE SELF
	LDA	0,.QUOTE
	JSR	@.PEEK
	JMP	FETQ	;// :"
	LDA	1,.QNOEV
	SNE	0,1
	JMP	FETNE	;// :#
	JSR	@.PNT
	FET2-.
	STAF	MODE	;//SET NOVA RETURN
	JSRII	.EFIND	;//LOOKUP-AND-APPLY TOKEN
.EFIND:	EFINDS
.QNOEV:	QNOEV	;//HASH OF "#"
.QUOTE:	QUOTE
FETNE:	JSR	@.AMPC
	LDA	1,TOKEN		;//FETCH NOEVAL (#)
	LDA	0,MXATM
	SLEU	1,0
	JMP	FETQ	;// :#INST LIKE :"INST
	LDA	2,GLOBX
	JSR	@.FIND
	NOP
	SKIP
FETQ:	LDA	0,TOKEN	;//QUOTED FETCH
	JSR	@.SVAL
FET2:	LDAF	GLOB	;//GET GLOBAL 
	STA	0,TGLOB
	JSR	@.AMPC
	LDA	1,.QPER	;//TEST FOR "." OR NIL
	SNL	0,0
	SNE	0,1
	JMP	@.ERET
	MOV	0,1
	LDA	2,TGLOB
	LDA	0,VALUE
	JSR	@.PUT	;//BIND NAME TO VALUE IN GLOBAL
	JMP	@.ARET	;//AND APPLY
TGLOB:	0
TSELF:	0
;//
;//	/* MATCH */
MAT1C:	JSR	@.AMPC	;//PICK UP TOKEN NAME
	STA	0,TGLOB	;//STORE IN TGLOB FOR TEMP
	LDAF	GLOB	;//SELF_GLOBAL TEMPORARILY
	LDA	1,SELF
	STA	1,TSELF
	JSR	@.SSLF
	LDA	0,TGLOB
	JSR	@.PEEK	;//TO PEEK AT GLOB.MESS.PC.1
	JMP	MAT2
	LDA	0,TSELF
	JSR	@.SSLF	;//RESTORE SELF
	JMP	@.FALS
MAT2:	LDA	0,TSELF
	JSR	@.SSLF	;//RESTORE SELF
	JMP	@.ERET
;//
;//	/* TO */	DEFINE A NEW TEMPLATE
TO1C:	JSR	@.AMPC	;//GET NAME
	STA	0,TONAM
	STAF	ARG0	;//SAVE IN 1ST LOCAL (X)
	JSR	@.LMPC
	STA	0,TOPT
	ZER	2,2
	STA	2,TOCT
TO2:	ISZ	TOPT	;//COUNT ATOMIC ARGS
	LDA	1,TOPT
	LOAD
	LDA	2,MXATM	;//IS IT AN ATOM
	SLEU	0,2
	JMP	TO3	;//NO, END COUNT
	ISZ	TOCT	;//YES, INC COUNT
	JMP	TO2
TO3:	LDA	1,TOCT	;//CALC MASK AND TABLE SIZE
	LDA	0,C3	;//AT LEAST 3
	ADD	0,1
	ZER	0,0
	MOVOL	0,0
	MOVZR	1,1,SZR
	JMP	.-2
	STA	0,TMASK	;//TABLE MASK
	LDA	1,C3
	ADDZL	1,0
	STA	0,TOCT
	JSR	@.LAL4	;//ALLOCATE BLOCK OF 2^(2N)+4 WORDS
	STA	2,TABLE
	STA	2,TOPT1
	NIL	0,0
TO4:	LDA	1,TOPT1	;//FILL IT WITH NILS
	STOR	
	ISZ	TOPT1
	DSZ	TOCT
	JMP	TO4
	LDA	1,TABLE	;//INSTALL CLASS FIELD
	LDA	0,MASTER
	STOR	
	LDA	0,TMASK	;//AND TABLE MASK
	LDA	1,TABLE
	INC	1,1
	STOR
	JSR	@.PNT
	FLAGS-.	;//TABLE POINTER
	STA	0,TOPT1
TO5:	JSR	@.AMPC	;//LOOP TO INSTALL EACH DECLARED ATOM
	LDA	1,MXATM	;//TEST END OF DECLS
	SLEU	0,1
	JMP	PUTCD
	LDA	1,.QCOLN
	SNE	0,1
	JMP	TO6
	LDA	1,@TOPT1	;//OR REMOTE BITS WITH ATOM
	ADD	0,1
	LDA	2,TOPT1
	LDA	0,BOFFS-FLAGS,2
	LDA	2,TOCT	;//VALUE IS BASE PLUS OFFSET
	SNL	0,0	;//  (UNLESS NIL)
	ADD	2,0
	LDA	2,TABLE
	JSR	@.SPUT	;//AND INSTALL ATOM IN TABLE
	ISZ	TOCT
	JMP	TO5
TO6:	LDA	2,TOPT1
	LDA	1,TOCT
	STA	1,ARSIZ-FLAGS,2	;//STORE COUNT OF LAST DECL TYPE
	ZER	1,1
	STA	1,TOCT	;//ZERO NEXT COUNT
	ISZ	TOPT1
	LDA	0,@TOPT1
	SNN	0,0	;//IGNORE BEYOND 2 SEPARATORS
	DSZ	TOPT1
	JMP	TO5
PUTCD:	LDA	2,TOPT1	;//GET LAST COUNT
	LDA	1,TOCT
	STA	1,ARSIZ-FLAGS,2	;//STORE COUNT OF LAST DECL TYPE
	LDA	1,.QDO	;//PUT CODE IN WITH NAME "@DO
	LDA	2,TABLE
	JSR	@.SPUT
	STA	1,DOLOC	;//STACHE VMEM LOC FOR FAST ACCESS
	LDA	0,INSIZ
	SNZ	0,0
	JMP	PCD1
	JSR	@.INTN
	LDA	1,.QSIZE
	LDA	2,TABLE
	JSR	@.SPUT
PCD1:	LDA	1,TABLE
	INC	1,1
	INC	1,1
	LDA	0,ARSIZ	;//INSTALL ACT REC SIZE IN TABLE
	LDA	2,BOFFS
	ADD	2,0
	STOR	
	LDA	0,DOLOC	;//INSTALL FAST PTR TO DO FIELD
	INC	1,1
	STOR
	LDA	0,TONAM
	JSR	@.SVAL	;//ATOMIC NAME IS RETURNED AS VALUE
	LDA	1,.QTITL	;//INSTALL NAME AS "@TITL
	LDA	2,TABLE
	JSR	@.SPUT
	LDA	2,SELF	;//THEN BIND THIS TABLE
	LDA	1,VALUE		;//TO ITS GIVEN NAME
	LDA	0,TABLE
	JSR	@.PUT
	LDA	0,TABLE	;//FIX REF CT
	JSR	@.REFD
	JMP	@.EVAL	;//DONE
DOLOC:	0
.QCOLN:	QCOLN
.QTITL:	QTITL
;//	THREE PARALLEL TABLES - FLAGS, SIZ, OFFS
FLAGS:	1B0	;//ACTIVATION FLAG
	1B0+1B1	;//INSTANCE FLAG
	0	;//CLASS FLAG
	-1
ARSIZ:	0	;//ACTVATION ARG COUNT
INSIZ:	0	;//INSTANCE ARG COUNT
CLSIZ:	0	;//CLASS ARG COUNT (NOT USED)
BOFFS:	ARG0	;//ACTIVATION OFFSET
	0	;//INSTANCE OFFSET
	-1	;//CLASS VALUE = NIL
TABLE:	0
TMASK:	0
TONAM:	0
TOPT:	0
TOCT:	0
TOPT1:	0
;//
;//	/* EQ - POINTER COMPARE */
EQ1C:	JSR	@.FECH
	JSR	@.REFI
	STAF	ARG0
	JSR	@.FECH
	STA	0,EQX
	LDAF	ARG0
	LDA	1,EQX
	SEQ	0,1
	JMP	@.FALS
	JMP	@.ERET
EQX:	0
;//
;//	/* NULL */   TESTS IF LOCAL VARIABLE UNDEFINED.
NULLC:	LDAF	ARG0	
	SNL	0,0	;//SKIP IF TOKEN IS NIL (VALUE = 1)
	JMP	@.FALS
	JMP	@.ERET	;//RETURN
;//
;//	/* APPLY-RETURN */
APRETC:	JSR	@.FECH	;//FETCH VALUE
	LDAF	GLOB
	STA	0,GLOB1
APR1:	JSR	@.SRET	;//RETURN UP TO GLOBAL
	JSR	@.ERR
	LDA	0,SELF
	LDA	1,GLOB1
	SEQ	0,1
	JMP	APR1
	JMP	@.ARET	;//AND APPLY VALUE
GLOB1:	0
;//
;//	/* ISNEW? */ TEST INSTANCE AND ALLOCATE IF NIL
ISNEWC:	LDAF	GLOB
	LDA	1,.INS
	ADD	0,1	;//FIND GLOBAL.INSTANCE
	STA	1,INSPT
	LOAD
	SNL	0,0
	JMP	@.FALS	;//NOT NIL - RETURN EMPTY
	LDAF	GLOB
	MOV	0,1
	LOAD
	STA	0,CLSPT	;//POINTER TO CLASS DEF
	MOV	0,2
	LDA	1,.QSIZE
	JSR	@.SGET	;//LOOK UP SIZE OF INSTANCE
	ZER	0,0,SKP
	JSR	@.IVAL
	INC	0,0
	LDA	1,CLSPT
	JSR	MKINSC	;//ALLOCATE AND NIL A NEW INSTANCE
	LDA	1,INSPT
	STOR	;//INSTALL IN INSTANCE FIELD
	JMP	@.ERET
.INS:	INST
INSPT:	0
CLSPT:	0
;//
;//	/* MAKE INSTANCE */ AC0=SIZE(TOTAL), AC1=CLASS, AC0 RETURNS PTR
MKINSC:	STA	0,SIZE
	STA	1,CLASS
	STA	3,MKRT
	JSR	@.LALO	;//GET SOME STORAGE
	STA	2,IPT1
	MOV	2,1
	LDA	0,CLASS
	STOR		;//INSTALL CLASS FIELD
	NIL	0,0
	JMP	NLP1
NILP:	INC	1,1
	STOR		;//NIL EACH WORD OF THE NEW INSTANCE
NLP1:	DSZ	SIZE
	JMP	NILP
MAKX:	LDA	0,IPT1	;//RETURN POINTER
	JMP	@MKRT
IPT1:	0
SIZE:	0
CLASS:	0
MKRT:	0
;
;	/* QUOTED FETCH */
QFETC:	JSR	LGMPC1
	SNN	0,0
	JMP	ZZZ
	STA	0,TV
	MOV	1,0
	MOV	2,1
	STOR
	LDA	0,TV
ZZZ:	JSR	@.SVAL
	JMP	@.ARET
TV:	0
;
;	/* PEEK AT NEXT TOKEN */
PEEKC:	JSR	LGMPC1
	JMP	ZZZ
;
LGMPC1:	STA	3,LGMPX
	LDAF	GLOB	;GLOBAL
	LDA	1,.ME
	ADD	0,1	;  .MESSAGE
	LOAD
	LDA	1,.PC
	ADD	0,1	;  .PC
	LOAD
	MOV	1,2	;	SAVE LOC[PC] IN AC2
	INC	0,1	;  .1
	LOAD
	JMP	@LGMPX
LGMPX:	0
.PC:	PC
.ME:	MESS
;
LASTOFCODE:	0
	.END
 
  