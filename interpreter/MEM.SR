	.TITL	MEM
	.GETNOLIST	"SMALL.OPS"
	.GETNOLIST	"SMALL.SYMS"
	.GETNOLIST	"SMALL.PARMS"
	.ZREL	;//ENTRY POINTS
.STOR:	STORE
.LOAD:	LOADE
.DLOAD:	DLOADE
.SCL:	JERR	;OBSOLETE, BUT KEPT TO MAINTAIN ORDER
.SPC:	JERR	;IN PAGE0
.SMO:	JERR
.SME:	JERR
.SGL:	JERR
.SRE:	JERR
.SA0:	JERR
.LARG:	LARG
.SARG:	SARG
.STREF:	STREF
.SSLF:	SSELF
.APC:	APC
.AMPC:	AMPC
.NEXT:	NEXT
.PEEK:	PEEK
.LMPC:	LMPC
.MOVE:	MOVE
.LINS:	LINST
.SINS:	SINST
.LNST:	LNST
.SNST:	SNST
.PNT:	PNT
.LSI:	LSI
MEMBITS:	JERR	;STORED INTO IN CRANK AND JUNTA
;	(HAS TO POINT TO NREL INITIALLY, SO SWAT WILL 
;	GIVE YOU MEMBITS+N NICELY!)
	.SREL
;
AXPC:	AXPCC
XPK:	XPKC
MEMSIZE:	40000	;NEED AN NREL LABEL SO SWAT WILL GIVE RV
VM2CR:	VM2COR
CR2VM:	COR2VM
SRLSI:	SRLSIC
	.NREL
-1
JERR:	JMP	@.ERR
;
;	/* LOAD */
LOADE:	STA	3,T3
	LDA	3,MEMBITS
	ADD	1,3
	LDA	0,0,3
	JMP	@T3

;	/* STORE */
STORE:	STA	3,T3
	LDA	3,MEMBITS
	ADD	1,3
	STA	0,0,3
	JMP	@T3

;	/* DBL LOAD */
DLOADE:	STA	3,T3
	LDA	3,MEMBITS
	ADD	1,3
	LDA	0,0,3
	LDA	1,1,3
	JMP	@T3
T3:	0
;
;	/* LARG, SARG - ACCESS TO AREC TEMPS
LARG:	LDA	2,.ARCL
	ADD	1,2
	LDA	0,ARG0,2
	JMP	0,3
SARG:	LDA	2,.ARCL
	ADD	1,2
SA1:	LDA	1,ARG0,2
	STA	0,ARG0,2
	STA	0,T0
	STA	3,T1
	MOV	1,0
	JSR	@.REFD	;DEC REF CT OF PREV ENTRY
	LDA	0,T0
	JMP	@T1
T0:	0
T1:	0
;
;	/* STORE WITH REF CT */ - MEANING DEC REF CT OF PREVIOUS
STREF:	STA	3,STRX
	STA	0,T0
	LDA	3,MEMBITS
	ADD	1,3
	LDA	0,0,3
	STA	0,T1	;REMEMBITSER OLD GUY
	LDA	0,T0
	STA	0,0,3	;INSTALL NEW GUY
	LDA	0,T1
	STA	1,T1
	JSR	@.REFD	;REFD OLD GUY
	LDA	0,T0
	LDA	1,T1	;RESTORE AC0,1
	JMP	@STRX
STRX:	0
;
;	/* STORE INTO SELF */ - UPDATE PAGE0 POINTERS
SSELF:	STA	0,SELF
	LDA	2,MEMBITS
	ADD	0,2
	STA	2,.ARCL
	INC	2,2
	STA	2,.ARPC
	INC	2,2
	STA	2,.ARMO
	INC	2,2
	STA	2,.ARME
	INC	2,2
	STA	2,.ARGL
	INC	2,2
	STA	2,.ARRE
	INC	2,2
	STA	2,.ARIN
	INC	2,2
	STA	2,.ARA0
	JMP	0,3
; 
;	/* ADVANCE MESSAGE.PC */
AMPC:	LDAF	MESS
AXPCC:	LDA	2,MEMBITS
	ADD	0,2,SKP		;AC2 _ MESS
;
APC:	LDA	2,.ARCL		;OR CURRENT
	LDA	1,PC,2		;AC1 _ PC
	STA	3,T3
	LDA	3,MEMBITS
	ADD	1,3
	LDA	0,1,3	;AC0 _ TOKEN
	SNL	0,0
	 ISZ	PC,2		; STEP PC IF NOT NIL
	JMP	@T3		;AND RETURN WITH TOKEN IN AC0
; 
;	/* LOAD MESSAGE.PC */	;AC0 _ MESS.PC
LMPC:	LDAF	MESS
	LDA	2,MEMBITS
	ADD	0,2
	LDA	0,PC,2
	JMP	0,3
;
;	/* NEXT */	AC0 _ NEXT TOKEN, AC1 _ ITS ADDR
NEXT:	STA	3,T3
	LDA	3,MEMBITS
	ADD	1,3
	LDA	0,1,3	;AC0 _ TOKEN
	SNL	0,0
	 INC	1,1	;INC AC1 IF NOT NIL
	JMP	@T3
;
;	/* PEEK */ - MATCH MESS.PC.1 AGAINST AC0; STEP IF =
PEEK:	STA	3,PKRET
	STA	0,PKT	;SAVE TOKEN TO MATCH
	LDAF	MESS	;IN-LINE COPY OF LMPC
PK1:	LDA	2,MEMBITS	;.
	ADD	0,2	;.
	LDA	1,PC,2	;.(BUT INTO AC1)
	LDA	3,MEMBITS
	ADD	1,3
	LDA	0,1,3	;AC0 _ TOKEN
	LDA	3,PKT	;AC3 _ TOKEN TO MATCH
	SNL	0,0
	SEQ	0,3
	 JMP	PKR2	;NO MATCH - 2ND RETURN
	LDA	3,.QPER
	SEQ	0,3	; (DON'T GOBBLE ".")
	isz	PC,2	;MATCHES - ADVANCE MESS.PC
	JMP	@PKRET	;AND TAKE FIRST RETURN
PKR2:	LDA	3,PKRET
	JMP	1,3
PKRET:	0
PKT:	0
;
XPKC:	STA	3,PKRET	;ENTRY WITH MESS IN AC1
	STA	0,PKT	;SAVE TOKEN TO MATCH
	MOV	1,0
	JMP	PK1
; 
;	/* CORE-TO/FROM VMEM */
VM2COR:	STA	3,MOVRT	;*MOVE STATE FROM VMEM TO CORE
	JSR	SETUP
V2C1:	LDA	1,VMMPT
	ISZ	VMMPT
	LOAD
	STA	0,@CORPT
	ISZ	CORPT
	DSZ	MOVCT
	JMP	V2C1
	LDA	0,SELF
	JSR	@.SSLF	;INSTALL ABS SELF FOR ABS VMEM
	JSRII	.OVIN	;CLEAR OV REFCT TABLE
	JMP	MOVX
COR2VM:	STA	3,MOVRT	;*MOVE STATE FROM CORE TO VMEM
	JSR	SETUP
C2V1:	LDA	0,@CORPT
	ISZ	CORPT
	LDA	1,VMMPT
	ISZ	VMMPT
	STOR
	DSZ	MOVCT
	JMP	C2V1
	JMP	MOVX
SETUP:	STA	0,SV0
	STA	1,SV1
	STA	2,SV2
	LDA	1,NMOVE		;SET UP FOR MOVE
	STA	1,MOVCT
	LDA	1,VMMOR
	STA	1,VMMPT
	LDA	1,COROR
	STA	1,CORPT
	JMP	0,3
MOVX:	LDA	0,SV0
	LDA	1,SV1
	LDA	2,SV2
	JMP	@MOVRT
SV0:	0
SV1:	0
SV2:	0
MOVRT:	0
COROR:	TLMEM	;CORE ORIGIN OF STATE
CORPT:	0
NMOVE:	4	;NUMBER WORDS TO MOVE
VMMOR:	MSAVE	;VMEM ORIGIN OF STATE
MOVCT:	0
VMMPT:	0
.OVIN:	OVINIT
;
;	/* LOAD AN INSTANCE FIELD */
LINST:	STA	3,LIRET
	LDAF	INST	;GET POINTER TO INSTANCE
	MOV	0,2,SKP
LNST:	 STA	3,LIRET	; ENTRY POINT FOR INSTANCE IN AC2
	STA	2,AC2	; SAVE
	LDA	1,@LIRET
	ADD	2,1	;ADD OFFSET TO POINTER
	LOAD
	JSR	@.IVAL	;AC0 _ NOVA INTEGER
	LDA	2,AC2	; RESTORE
	LDA	3,LIRET
	JMP	1,3	;RETURN AFTER THE ARG
;
;	/* STORE AN INSTANCE FIELD */
SINST:	STA	3,LIRET
	STA	0,T
	LDAF	INST	;GET POINTER TO INSTANCE
	MOV	0,2
	LDA	0,T
	SKIP
SNST:	STA	3,LIRET	;ENTRY POINT FOR INSTANCE IN AC2
	STA	2,AC2
SI1:	JSR	@.INTN	;MAKE AN INTEGER FOR VAL IN AC0
	LDA	2,AC2	;GET POINTER TO INSTANCE
	LDA	1,@LIRET
	ADD	2,1	;ADD OFFSET TO POINTER
	JSR	@.STREF	;STORE, FREEING OLD GUY
	LDA	3,LIRET
	JMP	1,3	;RETURN +1
AC2:	0	;INSTANCE POINTER; AC2 SAVED FOR LNST, SNST
T:	0	;TEMP CELL
LIRET:	0	;RETURN POINTER
SITMP:	0	;TEMP CELL
;
;	/* MOVE ROUTINE (NON-OVERLAPPING) */	USE BLT LATER <---<<
;	AC0=SOURCE ADDR, AC1=COUNT, AC2=DEST ADDR
MOVE:	COM	1,1	;COMPLEMENT COUNT
	STA	0,SOURCE
	JMP	TEST
MOVLP:	LDA	0,@SOURCE	;DO THE COPY
	STA	0,0,2
	ISZ	SOURCE	;BUMP THE POINTERS AND COUNT
	INC	2,2
TEST:	INC	1,1,SZR	;TEST IF DONE
	JMP	MOVLP
	JMP	0,3	;RETURN
SOURCE:	0	;MOVING SOURCE POINTER

;//	/*POINT*/	-GET ADDRESS IN SPITE OF BLDR
PNT:	LDA	0,0,3	;//	JSR	@.PNT
	ADD	3,0	;//	FOO-.
	JMP	1,3	;//	<AC0 NOW = LOC(FOO)>
;
;	/* LOAD/STORE INSTANCE */
SRLSIC:	STA	3,LSIX	;ENTRY FOR TABLE IN SREL
	LDA	2,0,3
	STA	2,CPTR
	JMP	NOADD
;
LSI:	STA	3,LSIX
	LDA	2,0,3	;1ST ARG=CORE ADDR - .
	ADD	3,2
	STA	2,CPTR
;
NOADD:	LDA	2,.LNST
	SZE	1,1	;AC1=0/1 FOR LOAD/STORE
	LDA	2,.SNST
	STA	2,ROUTN
	LDA	1,1,3	;2ND ARG=FIRST INST FIELD NO (1 FOR FIRST)
	STA	1,FIELD
	LDA	1,2,3	;3RD ARG=NUMBER OF FIELDS (1 FOR ONE)
	STA	1,CNT
	MOV	0,2	;AC0=INSTANCE PTR
LSILP:	LDA	0,@CPTR
	JSR	@ROUTN
FIELD:	0
	STA	0,@CPTR
	ISZ	CPTR
	ISZ	FIELD
	DSZ	CNT
	JMP	LSILP
	LDA	3,LSIX
	JMP	3,3
LSIX:	0
ROUTN:	0
CNT:	0
CPTR:	0
	.END
