	.TITL BCPLFP
;BCPL FLOATING POINT ROUTINES
; R. Sproull 6/73
;
;Brief description of the routines:
;
;There are <ACNO> floating-point accumulators.
;These accumulators may be loaded, stored, operated on,
;and tested with the following operations.
;
; FLD (acnumber,arg)
;	Load the specified accumulator from source specified
;	by arg. See below for a definition of 'arg'.
;
; FST (acnumber, ptr-to-fp-number)
;	Store the contents of the accumulator into a 4-word
;	SMALLTALK format.
;
; FTR (acnumber) ==> integer
;	Truncate the floating point number in the accumu-
;	lator and return the integer value.  Error if number
;	in ac cannot fit in an integer representation.
;
; FLDI (acnumber,integer)
;	Load-immediate of an accumulator with the integer
;	contents (signed 2's complement).
;
; FNEG (acnumber)
;	Negate the contents of the accumulator.
;
; FAD (acnumber,arg)
;	Add the number in the accumulator to the number
;	specified by arg and leave the result in
;	the accumulator. See below for a definition of 'arg'.
;
; FSB (acnumber,arg)
;	Subtract the number specified by 'arg' from the
;	number in the accumulator, and leave the result
;	in the accumulator.
;
; FML (acnumber,arg)  [ also FMP ]
;	Multiply the number specified by 'arg' by the number
;	in the accumulator, and leave the result in the ac.
;
; FDV (acnumber,arg)
;	Divide the contents of the accumulator by the number
;	specified by arg, and leave the result in the ac.
;	Error if attempt to divide by zero.
;
; FCM (acnumber,arg) ==> integer
;	Compare the number in the ac with the number
;	specified by 'arg'. Return
;		-1 IF ARG1 < ARG2
;	 	 0 IF ARG1 = ARG2
;		 1 IF ARG1 > ARG2
;
; FSN (acnumber) ==> integer
;	Return the sign of the floating point number.
;		-1	if sign negative
;		 0	if value is exactly 0 (quick test!)
;		 1	if sign positive and number non-zero
;
;For special hackers only:
; FLDV (acnumber,ptr-to-vector)
;	Read the 4-element vector into the internal
;	representation of a floating point number.
;
; FSTV (acnumber,ptr-to-vector)
;	Write the accumulator into the 4-element vector in
;	internal representation.
;
;'ARG' in the above discussion means: if the 16-bit value is
;less than the number of accumulators (16), then use the
;contents of the accumulator of that number.  Otherwise,
;the 16-bit value is assumed to be a pointer to a SMALLTALK
;floating-point number.
;
;All of the functions listed above that do not have "==>"
;after them return their first argument as their value.
;
;A word about the SMALLTALK format:
; The first word is:
;	SMALLTALK type/ref ct.
; The second word is:
;	low-bit -- sign
;	high 15 bits -- unpacked exponent
; The 3rd and 4th words are same as unpacked format.
;
;Note this format permits packed numbers to be tested for
;sign, to be compared (by comparing first words first), to
;be tested for zero (first word zero is sufficient), and
;(with some care) to be complemented.
;
;If you wish to capture errors, put the address of a BCPL
;subroutine in the static FPerrprint.  The routine will be
;called with one parameter:
;	0	Exponent too large -- FTR
;	1	Exponent too large -- FST
;	2	Dividing by zero -- FDV
;	3	Ac number out of range (any routine)

	;**SMALLTALK
	.GETNOLIST	"SMALL.OPS"
	.BEXT		MKINS
	.BEXTZ		.QERR,	FPCLAS
	;**SMALLTALK
	.BEXT FLD		;LOAD
	.BEXT FST		;STORE
	.BEXT FTR		;TRUNCATE
	.BEXT FLDI		;LOAD IMMEDIATE
	.BEXT FNEG		;NEGATE
	.BEXT FAD		;ADD
	.BEXT FSB		;SUBTRACT
	.BEXT FML		;MULTIPLY
	.BEXT FDV		;DIVIDE
	.BEXT FCM		;COMPARE
	.BEXT FSN		;SIGN

ACNO=4			;NUMBER OF FLOATING-POINT ACCUMULATORS
;BCPLT=1	;**SMALLTALK;TEMPORARY CELL IN FRAME OF CALLER THAT
			;CAN BE USED BRIEFLY BY THE CODE.


	.SREL		;STATICS FOR ENTRIES, ETC.

FLD:	.FLD
FST:	.FST
FTR:	.FTR
FLDI:	.FLDI
FNEG:	.FNEG
FAD:	.FAD
FSB:	.FSB
FML:	.FML
FDV:	.FDV
FCM:	.FCM
FSN:	.FSN

			;POINTERS TO VARIOUS PROCEDURES
FPenter: ENTR		;entry prologue
FPaccheck: .ACCK	;check ac number
FPargcheck: .ARGCHK	;check general argument
FPerrxx: .ERR		;error printer
FPerrprint: .EPR	;dummy in case user fails to specify
FParet:	.ARET		;return ac number
FPrret:	.RRET		;return result in ac 0
FPwork:	.WORK		;WORK AREA

	.NREL

;INDICES INTO WORK AREA:
SPARE=0
T1=1			;TEMPORARIES
T2=2
T3=3
T4=4
T5=5
AC0=6			;SAVED AC 'S
AC1=7
S1=10			;SIGN, EXPONENT,MANTISSAS FOR ARG 1
E1=11
M1=12
N1=13
S2=14			;ARGUMENT 2
E2=15
M2=16
N2=17

AAN=20
AAM=21
TMB=22			;4 WORDS FOR TEMPORARY AC
ACB=26			;4*ACNON WORDS FOR AC'S


I=100000		;INDIRECT BIT

;%%ALTO%%
;.DMR JSRII =64000
.DMR JMPII =64000	;ALSO JSRII!!
MULX=61020		;ALTO INSTRUCTIONS
DIVX=61021
;%%NOVA%%
;.DMR JSRII =JSR @0,0
;.DMR JMPII =JMP @0,0
;MULX=73301
;DIVX=73101

; SIGN TEST

.FSN:	MOV	3,2	;STA	3,BCPLT,2	;**SMALLTALK
	JSRII	ENTR1
	JSRII	ACCK1
	LDA	0,@M1,2	;GET MANTISSA
	MOV	0,0,SNR	;CHECK FOR ZERO NUMBER
	 JMPII	 ARET1	;IT IS 0, RETRUN 0
	LDA	0,@S1,2	;GET SIGN
	MOV	0,0,SNR
	INC	0,0	;CHANGE 0 TO 1
	JMPII	ARET1	;RETURN ANSWER IN 0

;COMPARE ROUTINE.

.FCM:	MOV	3,2	;STA	3,BCPLT,2	;**SMALLTALK
	JSRII	ENTR1
	JSRII	ACCK1
	JSRII	ARGC1
	LDA	0,@S1,2	;SIGN OF FIRST ARG
	LDA	1,@S2,2	;AND SECOND ARG
	MOVL	0,0,SZC	
	 JMP	 CM1N	;FIRST ARGUMENT NEGATIVE
	MOVL	1,1,SZC
	 JMP	 RET1	;SECOND ARG NEGATIVE (+ -)
	MOVZL	3,3	;TURN OFF LOW ORDER BIT OF AC3
	JMP	CM	;SECOND ARG POSITIVE (+ +)

CM1N:	MOVL	1,1,SNC
	 JMP	 RETM1	;SECOND ARGUMENT POSITIVE (- +)
	MOVOL	3,3	;TURN ON LOW ORDER BIT OF AC3
CM:	LDA	0,@M1,2
	LDA	1,@M2,2	;GET MANTISSAS
	AND#	0,1,SNR	;CHECK TO SEE IF EITHER IS 0
	 JMP	 CMZ	; YES -- ONE IS.
	LDA	0,@E1,2
	LDA	1,@E2,2
	SUB	0,1,SZR
	 JMP	 CMA	;IF EXPONENTS NOT EQUAL, DONE
	LDA	0,@M1,2
	LDA	1,@M2,2
	SUBO	0,1,SZR
	 JMP	 CMC	;IF FIRST MANTISSAS NOT EQUAL, DONE
	LDA	0,@N1,2
	LDA	1,@N2,2
	SUBO	0,1,SZR
	 JMP	 CMC	;IF SECOND MANTISSAS NOT EQUAL, DONE
CMB:	SUB	0,0
	JMPII	ARET1	;ZERO IS THE ANSWER

CMZ:	SUB#	0,1,SNR	;CHECK TO SEE WHICH IS ZERO
	 JMP	 CMB	;BOTH -- RETURN EQUALITY
	COM	1,1,SKP
CMC:	MOVR	1,1	;COPY CARRY TO HIGH ORDER BIT
CMA:	MOVL	1,1,SZC	;CHECK SIGN OF AC1
	 COM	 3,3	;COMPLEMENT 3 (ESSENTIALLY COMPUTING
			;XOR OF AC1SIGN AND AC3LOWBIT)
	MOVR	3,3,SZC	;NOW CHECK LOW ORDER BIT OF AC3
RET1:	SUBZL	0,0,SKP	;RETURN 1
RETM1:	ADC	0,0	;MINUS 1
	JMPII	ARET1	;RETURN


;NEGATE ROUTINE

.FNEG:	MOV	3,2	;STA	3,BCPLT,2	;**SMALLTALK
	JSRII	ENTR1
	JSRII	ACCK1
	LDA	0,@S1,2	;GET SIGN
	LDA	1,@M1,2	;AND FIRST MANTISSA
	MOV	1,1,SZR	;
	COM	0,0	;CHANGE SIGN IF NUMBER NOT
			;ALREADY ZERO
	STA	0,@S1,2
	JMPII	RRET1


;TRUNCATE


.FTR:	MOV	3,2	;STA	3,BCPLT,2	;**SMALLTALK
	JSRII	ENTR1
	JSRII	ACCK1
	LDA	0,@E1,2	;GET EXPONENT
	SUBZL	1,1	;AC1 <= 1
	SUBZL#	1,0,SZC	;IF EXPONENT <=0,
	 JMP	 CMB	;RETURN ZERO.
	LDA	3,TR16	;GET 16 DECIMAL
	SUB	0,3
	MOVL#	3,3,SZC
	 JMP	 FTRER	;EXPONENT TOO LARGE!
	LDA	0,@M1,2	;MANTISSA
	SUBZ	1,3,SNC	;SUBTRACT 1 FROM SHIFT COUNT
	 JMP	.+3
	MOVZR	0,0
	JMP	.-3	;LOOP SHIFTING
	LDA	1,@S1,2	;SIGN
	MOVL	1,1,SZC
	NEG	0,0	;COMPLEMENT ANSWER
	JMPII	ARET1	;RETURN ANSWER.

TR16:	16.

FTRER:	JSRII	ERR1	;CALL ERROR PRINTER
	0		;EXPONENT TOO LARGE

;%%ALTO%%
ACCK1:	FPaccheck	;goddamned Alto designers that
ENTR1:	FPenter		;don't allow JSRII to have index field
ARGC1:	FPargcheck
RRET1:	FPrret
ARET1:	FParet
ERR1:	FPerrxx
;%%NOVA%%
;ACCK1:	@FPaccheck
;ENTR1:	@FPenter
;ARGC1:	@FPargcheck
;RRET1:	@FPrret
;ARET1:	@FParet
;ERR1:	@FPerrxx

;LOAD AND STORE

.FLD:	MOV	3,2	;STA	3,BCPLT,2	;**SMALLTALK
	JSRII	ENTR1
	JSRII	ACCK1
	JSRII	ARGC1	;PROCESS SECOND ARG.
	LDA	0,@S2,2	;TRANSFER SECOND ARGUMENT
	STA	0,@S1,2	;TO FIRST
	LDA	0,@E2,2	;IN ALL FOUR POSITIONS.
	STA	0,@E1,2
	LDA	0,@M2,2
	STA	0,@M1,2
	LDA	0,@N2,2
	STA	0,@N1,2
	JMPII	RRET1	;FINI!


;STORE

.FST:	MOV	3,2	;STA	3,BCPLT,2	;**SMALLTALK
	JSRII	ENTR1
	JSRII	ACCK1
	;**SMALLTALK
	STA	2,Y2	;SAVE BASE
	LDA	1,FPCLAS ;TYPE
	LDA	0,C4	;SIZE
	JSRII	.MKINS	;ALLOCATE NUMBER INSTANCE
	STA	0,PT0
	LDA	2,Y2
	LDA	0,@S1,2
	LDA	1,@E1,2
	MOVL	0,0	;PACK SIGN IN WITH EXPT
	MOVL	1,0
	LDA	1,PT0
	INC	1,1
	STOR		;STORE EXPONENT/SIGN
	INC	1,1
	LDA	2,Y2
	LDA	0,@M1,2
	STOR		;STORE MANTISSA HI
	INC	1,1
	LDA	2,Y2
	LDA	0,@N1,2
	STOR		;STORE MANTISSA LO
	LDA	0,PT0
	LDA	2,Y2
	JMPII	ARET1	;RETURN POINTER TO NEW INSTANCE
Y2:	0	;SAVE BASE HERE
PT0:	0	;SAVE PTR HERE
C4:	4
.MKINS:	MKINS
	;**SMALLTALK



;ARITHMETIC ROUTINES (UGH)

.FML:	MOV	3,2	;STA	3,BCPLT,2	;**SMALLTALK
	JSRII	ENTR1
	JSRII	ACCK1
	JSRII	ARGC1	;GET ALL ARGUMENTS IN SHAPE
	LDA	0,@E1,2
	LDA	1,@E2,2
	ADD	1,0	;ADD EXPONENTS, LIKE IN ANY MULTIPLY
	STA	0,@E1,2
	LDA	0,@S1,2
	LDA	1,@S2,2
	MOV	1,1,SZR	;AND XOR SIGNS
	COM	0,0
	STA	0,@S1,2
	MOV	2,3	;*** PUT BASE REGISTER IN 3 ***
	SUB	0,0	;CLEAR AC0
	LDA	1,@M1,3
	LDA	2,@N2,3
	MULX		;HIGH*LOW
	STA	0,T1,3	;SAVE HIGH ORDER 16 BITS
	SUB	0,0	;CLEAR 0
	LDA	1,@M2,3
	LDA	2,@N1,3
	MULX		;OTHER HIGH*OTHER LOW
	LDA	1,T1,3
	ADDZ	1,0	;ADD RESULTS, SET CARRY IF OVL
	LDA	1,@M1,3	;HIGH
	LDA	2,@M2,3	;HIGH
	MULX		;HIGH*HIGH  (PLUS STUFF LEFT IN AC0!)
	MOV	0,0,SZC	;IF LOW+LOW RESULTED INA CARRY,
	 INC	 0,0	;NOW IS THE TIME TO ADD IT IN
			;NOW CHECK NORMALIZATION
	MOVL#	0,0,SZC
	 JMP	 .+5
	MOVZL	1,1	;SHIFT LEFT LOW BITS
	MOVL	0,0	;AND HIGH BITS
	DSZ	@E1,3	;DECREMENT EXPONENT TO ACCOUNT
	 MOV	 0,0	;IF IT DOES NOT SKIP
			;NOW CHECK ZERO RESULT.
	MOV	0,0,SZR	;IF HIGH BITS ZERO, TROUBLE.
	 JMP	 .+3
	STA	0,@E1,3
	STA	1,@S1,3	;THAT IS ZERO.
			;STORE RESULTS.
	STA	0,@M1,3
	STA	1,@N1,3
	MOV	3,2
	JMPII	RRET1	;AND RETURN.

.FDV:	MOV	3,2	;STA	3,BCPLT,2	;**SMALLTALK
	JSRII	ENTR1
	JSRII	ACCK1
	JSRII	ARGC1
	LDA	1,@M2,2	;GET DIVISOR MANTISSA
	MOV	1,1,SNR	;CHECK FOR ZERO.
	 JMP	 DIVER	;YES -- DIVIDE ERROR.
	LDA	0,@E2,2	;SUBTRACT EXPONENTS
	LDA	1,@E1,2
	SUB	0,1
	STA	1,@E1,2	;
	LDA	0,@S1,2
	LDA	1,@S2,2	;XOR SIGNS
	MOV	1,1,SZR
	COM	0,0
	STA	0,@S1,2
	MOV	2,3	;*** PUT BASE REGISTER IN 3 ***
	LDA	0,@M1,3
	MOV	0,0,SNR	;CHECK FOR DIVIDEND ZERO.
	 JMP	 DIV0	;YUP
	LDA	1,@N1,3
	LDA	2,@M2,3	;HIGH ORDER DIVISOR
	ADCZ#	0,2,SZC	;SKIPS IF AC0 GEQ AC2 UNSIGNED
	 JMP	 D0	;IF AC0 < AC2 GO DIVIDE
	MOVZR	0,0
	MOVR	1,1	;DIVIDE DIVIDEND BY TWO.
	ISZ	@E1,3	;BUMP EXPONENT BECAUSE OF SHIFT
	 MOV#	 0,0	;NOP
D0:	DIVX		;DIVIDEND/ HIGH-ORDER-DIVISOR
			;GUARANTEED NOT TO OVERFLOW BECAUSE
			;OF TEST A FEW LINES ABOVE
	 MOV# 0,0	;ALTO DIVIDE SKIPS
	STA	1,@M1,3	;SAVE HIGH ORDER RESULTS.
	SUB	1,1	;NOW AC0&1 HAVE REMAINDER,0
	DIVX		;REMAINDER/ HIGH-ORDER-DIVISOR
			;NO OVERFLOW BECAUSE REMAINDER<DIVISOR
	 MOV# 0,0	;ALTO DIVIDE SKIPS
	STA	1,@N1,3	;SAVE LOW ORDER RESULT.
			;NOW THE ANSWER IS 'TOO BIG' BECAUSE
			;LOW ORDER BITS OF DIVISOR WERE NOT
			;INCLUDED.  SO WE FORM CORRECTION
			;TERM (N2/M2)*HIGHANS
	SUB	0,0
	LDA	1,@N2,3	;LOW ORDER DIVISOR
	LDA	2,@M1,3	;HIGH ORDER ANSWER SO FAR
	MULX
	LDA	2,@M2,3	;HIGH ORDER DIVISOR
	ADCZ#	0,2,SZC	;CHECK TO SEE IF DIVIDE WILL OVERFLOW.
			;ADCZ SKIPS IF AC0 GEQ AC2 UNSIGNED
	 JMP	 D2	;NO -- GO DIVIDE
	DSZ	@M1,3	;YES -- DECREMENT HIGH ORDER PART OF
			;ANSWER (BECAUSE CORRECTION IS TO LOW
			;ORDER PART). DSZ WILL NEVER SKIP.
	SUB	2,0	;AND SUBTRACT 'ONE' FROM DIVIDEND
D2:	DIVX
	 MOV# 0,0	;ALTO DIVIDE SKIPS
	LDA	0,@N1,3	;UNCORRECTED LOW ORDER RESULT.
	SUBZ	1,0,SNC	;SUBTRACT SECOND CORRECTION
	 DSZ	 @M1,3	;DECREASE HIGH ORDER PART TOO -- WILL
			;NOT SKIP (HIGH PART NORMALIZED)
	LDA	2,@M1,3	;GET HIGH ORDER PART OF ANSWER
D3:	MOVL#	2,2,SZC	;CHECK NORMALIZATION -- COULD BECOME
	 JMP	 D1	;UNNORMALIZED BECAUSE OF EITHER 'DSZ'
	MOVZL	0,0	;CORRECTION ABOVE
	MOVL	2,2
	DSZ	@E1,3	;DECREMENT EXPONENT
	 MOV#	 0,0
D1:	STA	2,@M1,3	;STORE ANSWER
	STA	0,@N1,3
	MOV	3,2
	JMPII	RRET2

DIV0:	STA	0,@E1,3	;ZERO EXPONENT
	STA	0,@S1,3	;AND SIGN
	MOV	0,2
	JMP	D1	;AND EXIT

DIVER:	JSRII	ERR2
	2		;DIVIDE BY ZERO


;ADDITION AND SUBTRACTION ROUTINES (EVEN HARDER)

;	SHIFT EITHER OF ARGUMENTS UNTIL THEY MATCH.
;	RESULTS ARE LEFT AS FOLLOWS:
;		EXPONENT -- IN E1
;		MANTISSA OF ARG 1 -- IN M1,N1
;		MANTISSA OF ARG 2 -- IN AAM,AAN
 
PRESHIFT:
	STA	3,T1,2	;SAVE RETURN ADDRESS
	LDA	0,@M1,2	;MANTISSA FOR ZERO CHECK
	LDA	1,@M2,2
	AND#	0,1,SNR	;IF EITHER ARGUMENT ZERO,
	 JMP	 NOSHZ	;NO SHIFT REQUIRED BECAUSE ZERO
	LDA	0,@E1,2
	LDA	3,@E2,2
	SUB	0,3,SNR	;ARE EXPONENTS THE SAME?
	 JMP	 NOSH	;NO SHIFT
	MOVL#	3,3,SZC	;CHECK SIGNS
	JMP	SE2	; E2 < E1
			; E1 < E2
	LDA	0,@E2,2
	STA	0,@E1,2	;SHIFT UNTIL EXPONENT MATCHES E2
	NEG	3,3	;- NUMBER OF SHIFTS
	LDA	0,C31	;
	ADDL#	0,3,SZC	;SEE IF TOO FAR TO SHIFT.
	 JSR	 SE4	; YES -- FIX -- IGNORE NEXT 6 INSTRS.
	LDA	0,@M1,2	;! GET THE NUMBER
	LDA	1,@N1,2	;!
	MOVZR	0,0	;!
	MOVR	1,1	;! SHIFTED
	INC	3,3,SZR	;!
	 JMP	 .-3	;! LOOP UNTIL SHIFTS DONE.
	STA	0,@M1,2
	STA	1,@N1,2
NOSH:	LDA	0,@M2,2	;COPY SECOND ARGUMENT
	STA	0,AAM,2
	LDA	0,@N2,2
	STA	0,AAN,2
	JMP	@T1,2	;RETURN

NOSHZ:	MOV	0,0,SZR	;IF SECOND ARGUMENT ZERO,
	 JMP	 NOSH	;JUST COPY IT TO ITS TEMPS.
	LDA	0,@E2,2	;ELSE COPY SECOND ARGUMENT'S EXPONENT
	STA	0,@E1,2	;INTO ARGUMENT 1'S, AND
	JMP	NOSH	;COPY ARGUMENT 2 TO ITS PLACE
 
SE2:	LDA	0,C31
	ADDL#	0,3,SZC
	 JSR	 SE4	;TOO FAR TOOHIFT -- IGNORE 6 INSTRS.
	LDA	0,@M2,2	;! SHIFT ARG2
	LDA	1,@N2,2	;!
	MOVZR	0,0	;!
	MOVR	1,1	;!
	INC	3,3,SZR	;!
	 JMP	 .-3	;! LOOP SHIFTING
	STA	0,AAM,2	;SAVE IN SPECIAL PLACE
	STA	1,AAN,2	;TO AVOID CLOBBERING NUMBER.
	JMP	@T1,2

SE4:	SUB	0,0	;MAKE BOTH MANTISSAS ZERO
	MOV	0,1
	JMP	6,3	;AND BYPASS THE SHIFT LOOP
C31:	37

;%%ALTO%%
ACCK2:	FPaccheck	;goddamned Alto designers that
ENTR2:	FPenter		;don't allow JSRII to have index field
ARGC2:	FPargcheck
RRET2:	FPrret
ARET2:	FParet
ERR2:	FPerrxx

;%%NOVA%%
;ACCK2:	@FPaccheck
;ENTR2:	@FPenter
;ARGC2:	@FPargcheck
;RRET2:	@FPrret
;ARET2:	@FParet
;ERR2:	@FPerrxx

.FAD:	MOV	3,2	;STA	3,BCPLT,2	;**SMALLTALK
	JSRII	ENTR2
	JSRII	ACCK2
	JSRII	ARGC2
	JSR	PRESHIFT ;GO SHIFT ARGUMENTS.
	LDA	0,@S1,2	;ARG 1
	LDA	1,@S2,2	;ARG 2
	MOV#	0,0,SZR
	 JMP	 AD1N	;FIRST ARG NEGATIVE
	MOV#	1,1,SZR
	 JMP	 ADD2	;SECOND ARG NEGATIVE (+ + -)
	JMP	ADD1	;SECOND ARG POSITIVE (+ + +)
AD1N:	MOV#	1,1,SZR
	 JMP	 ADD1	;SECONG ARG NEGATIVE (- + -)
	JMP	ADD2	;SECOND ARG POSITIVE (- + +)

.FSB:	MOV	3,2	;STA	3,BCPLT,2	;**SMALLTALK
	JSRII	ENTR2
	JSRII	ACCK2
	JSRII	ARGC2
	JSR	PRESHIFT ;GO SHIFT ARGUMENTS.
	LDA	0,@S1,2	;ARG 1
	LDA	1,@S2,2	;ARG 2
	MOV#	0,0,SZR
	 JMP	 SB1N	;FIRST ARG NEGATIVE
	MOV#	1,1,SZR
	 JMP	 ADD1	;SECOND ARG NEGATIVE (+ - -)
	JMP	ADD2	;SECOND ARG POSITIVE (+ - +)
SB1N:	MOV#	1,1,SZR
	 JMP	 ADD2	;SECOND ARG NEGATIVE (- - -)
;	JMP	ADD1	;SECOND ARG POSITIVE (- - +)

ADD1:	LDA	0,@N1,2	;LOW ORDER ARG 1
	LDA	1,AAN,2	;LOW ORDER ARG 2
	LDA	3,@M1,2	;HIGH ORDER ARG 1
	ADDZ	1,0,SZC	;ADD LOW PARTS
	INCZ	3,3	;BUMP HIGH PART IF CARRY
	LDA	1,AAM,2	;HIGH ORDER ARG 2
	ADD	3,1,SNC	;ADD HIGH PARTS
	 JMP	 .+5	;NO CARRY
	MOVR	1,1	;POSTSHIFT
	MOVR	0,0
	ISZ	@E1,2
	 MOV	0,0	;NOP
	STA	0,@N1,2	;STORE RESULTS
	STA	1,@M1,2
	JMPII	RRET2	;DONE

ADD2:	LDA	0,@N1,2	;LOW ARG 1
	LDA	1,AAN,2	;LOW ARG 2
	SUBZ	1,0	;0 HAS LOW ORDER RESULT.
	LDA	1,@M1,2	;HIGH ORDER
	LDA	3,AAM,2
	MOV	0,0,SZC	;LOOK AT CARRY FROM SUBZ
	SUBZ	3,1,SKP	;IF THERE WAS A CARRY,
			;DO 2'S COMPL SUBTRACT
	ADCZ	3,1	;ELSE ONE'S COMPL SUB
	MOV	0,0,SZC	;IF NO CARRY, SIGN CHANGED!!!!
	 JMP	 NORMALIZE ;CARRY -- ALL DONE.
	NEG	0,0,SNR	;DOUBLE LENGTH NEGATE
	NEG	1,1,SKP
	COM	1,1
	LDA	3,@S1,2	;COMPLEMENT SIGN
	COM	3,3
	STA	3,@S1,2

NORMALIZE:
			;NUMBER IN 1 (HIGH) AND 0 (LOW)
	SUB	3,3	;SHIFT COUNT
	MOV	1,1,SNR	;IS HIGH ORDER PART ZERO?
	 JMP	 HIZ	;YES
NO1:	MOVL#	1,1,SZC	;NORMALIZED?
	 JMP	 NO2	;YES
	MOVZL	0,0	;LOW ORDER LEFT
	MOVL	1,1
	INC	3,3	;COUNT
	JMP	NO1	;AND LOOP.

HIZ:	MOV	0,1,SNR	;TRY JUST USING LOW BITS
	 JMP	 ALZ	;RESULT ALL ZEROES.
	LDA	3,NO16	;16 SHIFTS DONE LIKE WILDFIRE
	SUB	0,0	;AND ZERO LOW ORDER
	JMP	NO1	;REJOIN LOOP
NO16:	16.
ALZ:	STA	0,@E1,2	;ZERO EXPONENT.
	STA	0,@S1,2	;POSITIVE SIGN
NO2:	STA	1,@M1,2	;HIGH ORDER ANSWER
	STA	0,@N1,2
	LDA	1,@E1,2
	SUB	3,1	;ADJUST EXPONENT
	STA	1,@E1,2
	JMPII	RRET2	;AND RETURN.
;LOAD IMMEDIATE (OR 'LOAD INTEGER')

.FLDI:	MOV	3,2	;STA	3,BCPLT,2	;**SMALLTALK
	JSRII	ENTR2
	JSRII	ACCK2
	LDA	0,NO16	;GET 16 (10)
	STA	0,@E1,2	;EXPONENT
	SUB	3,3
	MOVL#	1,1,SNC
	 JMP	 .+3
	COM	3,3	;FLIP SIGN
	NEG	1,1	;AND NUMBER
	SUB	0,0	;LOW ORDER BITS OF MANTISSA
	STA	3,@S1,2	;STORE SIGN
	JMP	NORMALIZE

; VARIOUS INITIALIZATION ROUTINES.

ACER:	JSRII	ERR2	;CALL ERROR PRINTER
	3		;AC NUMBER OUT OF RANGE

;CHECK AN ARGUMENT THAT MAY BE EITHER AN AC NUMBER
;OR A POINTER TO A FLOATING POINT NUMBER

.ARGCHK:	STA	3,T1,2	;SAVE RETURN ADDRESS
	LDA	3,ACMSK
	AND#	3,1,SZR
	 JMP	 FARG0	;NOT AN AC!
	LDA	3,ACBEG	;INDEX INTO WORK TABLE
	ADD	2,3	;+ WORK TABLE BASE
	ADD	3,1
	STA	1,S2,2	;SIGN
	LDA	3,ACNON
	ADD	3,1
	STA	1,E2,2	;EXPONENT
	ADD	3,1
	STA	1,M2,2	;MANTISSA 1
	ADD	3,1
	STA	1,N2,2	;MANTISSA 2
	JMP	@T1,2	;RETURN

FARG0:	LDA	0,TMPAC	;INDEX IN WORK TABLE FOR TEMP AC
	ADD	2,0	;+ WORK TABLE BASE
	STA	0,S2,2
	INC	0,0
	STA	0,E2,2
	INC	0,0
	STA	0,M2,2
	INC	0,0
	STA	0,N2,2	;ADDRESSES SET UP.
			;NOW UNPACK THE NUMBER ==> 1
	;**SMALLTALK
	STA	2,X2	;SAVE BASE
	DLOAD		;AC0,1 _ TYPE,EXPT/SIGN
	MOVL	1,0	;SIGN-EXTEND
	ZER	0,0	;SIGN _ +
	MOVR	1,1,SZC	;SHIFT EXPT, TEST SIGN
	COM	0,0	;NEGATE SIGN
	LDA	2,X2	;RESTORE BASE
	STA	0,@S2,2	;SIGN
	STA	1,@E2,2	;EXPONENT
	LDA	1,AC1,2
	INC	1,1
	INC	1,1
	DLOAD		;AC0,1 _ MANT HI, MANT LO
	LDA	2,X2	;RESTORE BASE
	STA	0,@M2,2	;MANTISSA, HI
	STA	1,@N2,2	;MANTISSA, LO
	JMP	@T1,2	;RETURN...
X2:	0	;SAVE BASE HERE
	;**SMALLTALK

;EXIT ROUTINES:
; ARET -- RETURN FIRST ARGUMENT
; RRET -- RETURN CONTENTS OF AC0

ZRET:	SUB	0,0,SKP	;RETURN ZERO
.RRET:	LDA	0,AC0,2	;RESTORE FIRST ARGUMENT
.ARET:	LDA	2,CALLER	;GET FRAME
	JMP	0,2	;**SMALLTALK

;ENTRY PROLOGUE

ENTR:	STA	2,CALLER	;SAVE CALLER FRAME POINTER
	LDA	2,@LCON	;POINTER TO MY WORK AREA
	STA	0,AC0,2	;SAVE PARAMETERS
	STA	1,AC1,2
	JMP	0,3	;RETURN.
LCON:	FPwork		;POINTER TO STATIC FOR WORK AREA

;CHECK AN ARGUMENT THAT IS SUPPOSED TO BE
;AN ACCUMULATOR NUMBER

.ACCK:	STA	3,T1,2	;RETURN ADDRESS
	LDA	3,ACMSK
	AND#	3,0,SZR	;AC NUMBER IN RANGE?
	 JMP	 ACER	;ERROR
	LDA	3,ACBEG	;FIRST LOCATION OF AC SAVE AREA.
	ADD	2,3	;+ WORK TABLE ADDRESS
	ADD	3,0
	STA	0,S1,2	;POINTER TO SIGN
	LDA	3,ACNON	;GET NUMBER OF AC'S
	ADD	3,0
	STA	0,E1,2	;EXPONENT
	ADD	3,0
	STA	0,M1,2	;MANTISSA 1
	ADD	3,0
	STA	0,N1,2	;MANTISSA 2
	JMP	@T1,2	;RETURN.


ACNON:	ACNO		;NUMBER OF AC'S
ACMSK:	-ACNO		;MASK TO DECIDE IF AC IS ARGUMENT
CALLER:	0		;CALLER'S BCPL FRAME
TMPAC:	TMB		;INDEX IN WORK AREA OF TEMP AC
ACBEG:	ACB		;INDEX IN WORK AREA OF AC'S

;ERROR PRINTING MECHANISM
;

.EPR:	JMP 1,3		;DUMMY ERROR PRINTER

;COME HERE ON ERROR
;  ERROR NUMBER IMBEDDED UNDER CALL

.ERR:	LDA	0,0,3		;ERROR CODE TO AC 0
	;**SMALLTALK
	LDA	2,.ERTAB
	ADD	0,2
	LDA	3,0,2
	JMP	@.QERR
.ERTAB:	ERTAB
ERT0:	.TXT	"FP EXPON TOO LARGE"
ERT2:	.TXT	"FP DIV BY 0"
ERT3:	.TXT	"FP AC# ERROR"
	;**SMALLTALK



;********** WORK AREA AND OTHER GOODIES ****************

.WORK:	ENDWK-.	;LENGTH OF WORK AREA
	.BLK 7		;TEMPORARIES AND SAVED AC'S
	.BLK 10		;PINTERS TO EXPONENTS, MANTISSAS, ETC.
	.BLK 2
	.BLK 4		;temp ac
	.BLK 4*ACNO	;ac area
ENDWK:	0

	.SREL
ERTAB:	ERT0
	ERT0
	ERT2
	ERT3

	.END

  E
	NEG	1,1,SKP
	COM	1,1
	LDA	3,@S1,2	;COMPLEMENT SIGN
	COM	3,3
	STA	3,@S1,2

NORMÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿMP	 HIZ	;YES
NO1:	MOVL#	1,1,SZC	;NORMALIZED?
	 JMP	 NO2	;YES
	MOVZL	0,0	;LOW ORDER LEFT
	MOVL	1,1
	INC	3,3	;COUNT
	JMP	NO1	;AND LOOP.

HIZ:	MOV	0,1,SNR	;TRY JUST USING LOW BITS
	 JMP	 ALZ	;RESULT ALL ZEROES.
	LDA	3,NO16	;16 SHIFTS DONE LIKE WILDFIRE
	SUB	0,0	;AND ZERO LOW ORDER
	JMP	NO1	;REJOIN LOOP
NO16:	16.
ALZ:	STA	0,@E1,2	;ZERO EXPONENT.
	STA	0,@S1,2	;POSITIVE SIGN
NO2:	STA	1,@M1,2	;HIGH ORDER ANSWER
	STA	0,@N1,2
	LDA	1,@E1,2
	SUB	3,1	;ADJUST EXPONENT
	STA	1,@E1,2
	JMPII	RRET2	;AND LOW ORDER
	JMP	NO1	;REJOIN LOOP
NO16:	16.
ALZ:	STA	0,@E1,2	;ZERO EXPONENT.
	STÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿRETURN.
;LOAD IMMEDIATE (OR 'LOAD INTEGER')

.FLDI:	MOV	3,2	;STA	3,BCPLT,2	;**SMALLTALK
	JSRII	ENTR2
	JSRII	ACCK2
	LDA	0,NO16	;GET 16 (10)
	STA	0,@E1,2	;EXPONENT
	SUB	3,3
	MOVL#	1,1,SNC
	 JMP	 .+3
	COM	3,3	;FLIP SIGN
	NEG	1,1	;AND NUMBER
	SUB	0,0	;LOW ORDER BITS OF MANTISSA
	STA	3,@S1,2	;STORE SIGN
	JMP	NORMALIZE

; VARIOUS INITIALIZATION ROUTINES.

ACER:	JSRII	ERR2	;CALL ERROR PRINTER
	3		;AC NUMBER OUT OF RANGE

;CHECK AN ARGUMENT THAT MAY BE EITHER AN AC NUMBER
;OR A POINTER TO A FLOATING POINT NUMBEROW ORDER BITS OF MANTISSA
	STA	3,@S1,2	ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ

.ARGCHK:	STA	3,T1,2	;SAVE RETURN ADDRESS
	LDA	3,ACMSK
	AND#	3,1,SZR
	 JMP	 FARG0	;NOT AN AC!
	LDA	3,ACBEG	;INDEX INTO WORK TABLE
	ADD	2,3	;+ WORK TABLE BASE
	ADD	3,1
	STA	1,S2,2	;SIGN
	LDA	3,ACNON
	ADD	3,1
	STA	1,E2,2	;EXPONENT
	ADD	3,1
	STA	1,M2,2	;MANTISSA 1
	ADD	3,1
	STA	1,N2,2	;MANTISSA 2
	JMP	@T1,2	;RETURN

FARG0:	LDA	0,TMPAC	;INDEX IN WORK TABLE FOR TEMP AC
	ADD	2,0	;+ WORK TABLE BASE
	STA	0,S2,2
	INC	0,0
	STA	0,E2,2
	INC	0,0
	STA	0,M2,2
	INC	0,0
	STA	0,N2,2	;ADDRESSES SET UA	1,E2,2	;EXPONENT
	ADD	ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿP.
			;NOW UNPACK THE NUMBER ==> 1
	;**SMALLTALK
	STA	2,X2	;SAVE BASE
	DLOAD		;AC0,1 _ TYPE,EXPT/SIGN
	MOVL	1,0	;SIGN-EXTEND
	ZER	0,0	;SIGN _ +
	MOVR	1,1,SZC	;SHIFT EXPT, TEST SIGN
	COM	0,0	;NEGATE SIGN
	LDA	2,X2	;RESTORE BASE
	STA	0,@S2,2	;SIGN
	STA	1,@E2,2	;EXPONENT
	LDA	1,AC1,2
	INC	1,1
	INC	1,1
	DLOAD		;AC0,1 _ MANT HI, MANT LO
	LDA	2,X2	;RESTORE BASE
	STA	0,@M2,2	;MANTISSA, HI
	STA	1,@N2,2	;MANTISSA, LO
	JMP	@T1,2	;RETURN...
X2:	0	;SAVE BASE HERE
	;**SMALLTALK

;EXIT ROUTINES:
; ARET -- RETURN FIRST ARGUMENT
; RRET -- RETURN CONTENTS OF AC0

ZRET:	SUB	0,0,SKP	;RETURN ZERO
.RRET:	LDA	0,AC0,2	;RESTORE FIRST ARGUMENT
.ARET:	LDA	2,CALLER	;GET FRAME
	JMP	0,2	;**SMALLTALK

;ENTRY PROLOGUE

ENTR:	STA	2,CALLER	; RETURN FIRST ARGUMENT
; RRET -- RETURN CONTENTS OF AC0

ZRET:	SUB	0,0,SKP	;REÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿSAVE CALLER FRAME POINTER
	LDA	2,@LCON	;POINTER TO MY WORK AREA
	STA	0,AC0,2	;SAVE PARAMETERS
	STA	1,AC1,2
	JMP	0,3	;RETURN.
LCON:	FPwork		;POINTER TO STATIC FOR WORK AREA

;CHECK AN ARGUMENT THAT IS SUPPOSED TO BE
;AN ACCUMULATOR NUMBER

.ACCK:	STA	3,T1,2	;RETURN ADDRESS
	LDA	3,ACMSK
	AND#	3,0,SZR	;AC NUMBER IN RANGE?
	 JMP	 ACER	;ERROR
	LDA	3,ACBEG	;FIRST LOCATION OF AC SAVE AREA.
	ADD	2,3	;+ WORK TABLE ADDRESS
	ADD	3,0
	STA	0,S1,2	;POINTER TO SIGN
	LDA	3,ACNON	;GET NUMBER OF AC'S
	ADD	3,T1,2	;RETURN ADDRESS
	LDA	3,ACMSK
	AND#	3,0,SZR	;AC NUMÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ3,0
	STA	0,E1,2	;EXPONENT
	ADD	3,0
	STA	0,M1,2	;MANTISSA 1
	ADD	3,0
	STA	0,N1,2	;MANTISSA 2
	JMP	@T1,2	;RETURN.


ACNON:	ACNO		;NUMBER OF AC'S
ACMSK:	-ACNO		;MASK TO DECIDE IF AC IS ARGUMENT
CALLER:	0		;CALLER'S BCPL FRAME
TMPAC:	TMB		;INDEX IN WORK AREA OF TEMP AC
ACBEG:	ACB		;INDEX IN WORK AREA OF AC'S

;ERROR PRINTING MECHANISM
;

.EPR:	JMP 1,3		;DUMMY ERROR PRINTER

;COME HERE ON ERROR
;  ERROR NUMBER IMBEDDED UNDER CALL

.ERR:	LDA	0,0,3		;ERROR CODE TO AC 0
	;**SMALLTALK
	LDA	2,.ERTAB
	ADD	0,2
	LDA	3,0,2
	JMP	@.QERR
.ERTAB:	ERTAB
ERT0:	.TXT	"FP EXPON TOO LARGE"
ERT2:	.TXT	"FP DIV BY 0"
ERT3:	.TXT	"FP AC# ERROR"
	;**SMALLTALK



;********** WORK AREA AND OTHER GOODIES ****************

.WORK:	ENDWK-.	;LENGTH OF WORK AREA
	.BLK 7		;TEMPORARIES AND SAVED AC'S
	.BLK 10		;PINTERS TO EXPONENTS, MANTISSAS, ETC.
	.BLK 2
	.BLK 4		;TEMP AC
	.BLK 4*ACNO	;AC AREA

	.SREL
ERTAB:	ERT0
	ERT0
	ERT2
	ERT3

	.END
