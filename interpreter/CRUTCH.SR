	.TITL	CRUTCH	;// I/O and read-eval-print for BOOTSTRAP
;//	AFTER JUNTA HAS BEEN EXECUTED, THIS ROUTINE WILL SELF-DESTRUCT
;//	I.E. SMALLTALK WILL HANDLE I/O AND WILL EXPAND VMEM OVER THIS CODE

	.GETNOLIST	"SMALL.OPS"
	.GETNOLIST	"SMALL.SYMS"
	.GETNOLIST	"SMALL.PARMS"
.BEXT	SMALLTALK,KEYS,DISPLAY,OPENAFILE,GETS,CLOSEAFILE
DISKROCH=	3

	.SREL	;ENTRY POINTS
SMALLTALK:	ENTRY
TRACE:	TRACEC
READ1:	READ1C
USERL:	USERLC
PRIN1:	PRIN1C
STOP:	STOPC
FILIN:	FILINC
FNAME:	FNBLK
	.ZREL
.TGET:	TTGET
.TPUT:	TTPUT
.ERR:	ERR
.QERR:	QERR
.PICK:	PICKC
.STIK:	STIKC

	.SREL
READ:	READC
RED1:	RED1C
CRLF:	CRLFC
POCT:	POCTC
SPRT:	SPRTC
TTRD:	TTRDC
RATOMS:	RATOM
RDBUFS:	RDBUF
IBUFS:	IBUF
STACKS:	STACK
.TOKENB:	TOKENB
;
	.NREL
;//
;//	/* ENTER HERE FROM BCPL */
ENTRY:	STA	2,BSTACK
	INC	3,3
	STA	3,BRETURN
	JSRII	.VM2C	;// LOAD CORE STATE
	SNZ	0,0
	JMP	@.EVAL	;AC0=0 MEANS NO PAGING
	LDA	0,TLMEM
	LDA	1,BIG
	SLEU	0,1
	JSRII	.JUNTA	;[HACK!!] JUNTA IF MEM IS BIG
	JMP	@.EVAL	;// THEN START EVALLING...
.VM2C:	VM2CR
.JUNTA:	JUNTA
BIG:	30000
BSTACK:	0
BRETURN:	0
;//
;//	/* RETURN TO BCPL */
STOPC:	JSRII	.CR2V
	LDA	2,BSTACK
	JMP	@BRETURN
.CR2V:	CR2VM
;//
;//	/* PCHAR AND GCHAR */
TTPUT:	STA	3,T3
	STA	2,T2
	STA	1,T1
	LDA	2,BSTACK
	JSRII	.DISP
	1
	JMP	TTX
TTGET:	STA	3,T3
	STA	2,T2
	STA	1,T1
TGT1:	LDA	2,BSTACK
	LDA	0,@KSTRM
	JSRII	.GETS
	1
TTX:	LDA	1,T1
	LDA	2,T2
	JMP	@T3
T3:	0
T2:	0
T1:	0
KSTRM:	KEYS
.DISP:	DISPLAY

;// 
;//	/* FILIN */ - SETS .TGET TO  A FILE STREAM
FILINC:	ZER	1,1	;// GET FILE NAME
	JSR	@.LARG
	STA	0,FI2
	JSR	@.PNT	;// GET PTR TO FGET
	FGET-.
	LDA	1,.TGET	;// POINT .TGET TO FGET
	SNE	0,1
	JMP	FILERR
	STA	0,.TGET
;/? 
	LDA	0,FI2	;// PICK UP NAME ARG
	LDA	1,MXATM
	SLEU	0,1	;// ERROR IF NOT ATOMIC
	JMP	FILERR   
	MOV	0,1
	LOAD		;// GET PNAME
	LDA	1,@.FNAM
	MOVZL	1,1
	JSR	ST2CORC	;// COPY PNAME TO CORE
	JSR	@.PNT
	FILEOF-.
	LDA	2,BSTACK
	STA	0,3,2
	LDA	0,@.FNAM
	LDA	1,.ROCH
	JSRII	.OPEN	;// OPENAFILE(pname,rdonlychars,FILERR)
	3
	SNZ	0,0
	JMP	FILERR
	STA	0,STREAM
	JMP	@.EVAL
FILERR:	JSR	@.PNT
	TTGET-.
	STA	0,.TGET
	JSR	@.QERR
	.TXT	"filin choked!"
.FNAM:	FNAME
STREAM:	0
.ROCH:	DISKROCH
.OPEN:	OPENAFILE
FI2:	0
;//
;//	/* GET-CHAR FROM FILE */
FGET:	STA	3,T3
	STA	2,T2
	STA	1,T1
	LDA	2,BSTACK
	LDA	0,STREAM
	JSRII	.GETS
	1
	LDA	1,EFLG
	SNZ	1,1
	JMP	TTX
;//
	LDA	0,STREAM	;END-OF-FILE REACHED - CLOSE FILE
	JSRII	.CLOS
	1
FGT1:	JSR	@.PNT
	TTGET-.
	STA	0,.TGET	;// RESTORE KEYBOARD
	ZER	0,0
	STA	0,EFLG
	JMP	TGT1	;// AND PROCEED
;//
;FILEOF:
	ISZ	EFLG
	JMP	1,3
FILEOF:	JMP	.-2	;INCREDIBLE CROCK BECAUSE EOF SEEMS
	JMP	FGT1	;TO COME TO FILEOF+1 WITH GARBAGE IN AC3
EFLG:	0
.GETS:	GETS
.CLOS:	CLOSEAFILE
FNBLK:	.BLK	10
;//
;//	/* INITIAL QERR */
QERR:	LDA	2,BSTACK
	LDA	0,0,3
	LDA	1,LBMSK
	ANDS	0,1	;// LENGTH
	STA	1,SLEN
	MOVOL	3,0	;// BYTEPTR
	STA	0,MPTR
QLOOP:	JSR	@.PICK
	MPTR-.
	NOP
	JSR	@.TPUT
	DSZ	SLEN
	JMP	QLOOP
	JSR	@.PNT
	TTGET-.
	STA	0,.TGET	;//RESTORE KEYBOARD
	JSR	@.SRET
	JMP	.+2	;//POP UP TO TOP LEVEL
	JMP	.-2
	JMP	@.EVAL
;//
;//	/* COPY SMALLTALK STRING TO CORE */
ST2CORC:	STA	3,STRET
	STA	0,STPT	;//AC0=STRING POINTER
	STA	1,CORPT	;//AC1=CORE BYTE DESTINATION
	ZER	1,1
	STA	1,STPC
	INC	0,1
	LOAD		;//GET STRING LENGTH
	INC	0,1
	STA	1,STLEN
STLOOP:
	JSR	@.STIK	;//FIRST STORE LEN, THEN CHARS
	CORPT-.
	JSR	@.GNB
	STPC:	0
	STPT:	0
	DSZ	STLEN
	JMP	STLOOP
	ZER	0,0	;//END WITH A NULL
	JSR	@.STIK
	CORPT-.
	DSZ	CORPT
	LDA	1,CORPT	;//AC1 RETURNS NEXT BYTE PTR
	JMP	@STRET
STRET:	0
STLEN:	0
CORPT:	0
;// 
;//	/* TRACE */
TRACEC:	STA	3,TRACX
	LDAF	PC
	MOV	0,1
	JSR	@.NEXT
	STA	0,TOKEN
	MOV	1,0
	JSR	POCTC	;PRINT PC (NEXT)
	LDA	0,SELF
	JSR	POCTC	;PRINT PROCESS ADDR
	LDA	2,SELF 
	LDA	1,.QTITL
	JSR	@.GETT	;PRINT CLASS TITLE
	NOP
	JSR	SPRTC
	LDA	0,TOKEN
	JSR	SPRTC	;PRINT TOKEN NAME
	JSR	CRLFC
	JMP	@TRACX	;PROCEED
TRACX:	0
CR:	15
.QTITL:	QTITL
;
;	/* OCTAL PRINT */
POCTC:	STA	3,SAV3	;PRINT AC0 IN OCTAL
	JSR	SAVER
POC1:	MOV	0,1
	LDA	0,HMARK	;FLAG IT WITH A HASH MARK
	JSR	@.TPUT
	SUBZR	2,2	;THIS OCTAL ROUTINE FROM
OLOOP:	LDA	0,ASCI0		;PROGRAMMING THE NOVA COMPUTERS
	SUBO	2,1,SNC		;APPENDIX A, PAGE 5
	INC	0,0,SKP
	ADD	2,1,SKP
	JMP	.-3
	JSR	@.TPUT
	MOVZR	2,2
	MOVZR	2,2
	MOVZR	2,2,SZR
	JMP	OLOOP
	LDA	0,SPACE	;END IT WITH A SPACE
	JSR	@.TPUT
	JMP	RESTR
HMARK:	43	;"#"
ASCI0:	60	;"0"
SPACE:	40	;" "
;
;	/* ATOM PRINT */
STPRT:	STA	3,SAV3	;REAL STRING ENTRY
	JSR	SAVER
	JMP	SPRTC1
SPRTC:	STA	3,SAV3	;PRINT NAME OF ATOM IN AC0
	JSR	SAVER
	LDA	3,MXATM
	SLEU	0,3
	JMP	POC1	;OCTAL PTR IF NOT ATOM
	MOV	0,1
	LOAD		;GET PNAME ADDR
	SNN	0,0
	JMP	SPR1	;BRANCH IF NO PNAME
SPRTC1:	INC	0,1
	STA	1,MPTR
	LOAD
	INC	0,0
	STA	0,SLEN	;MAX STRING LEN
WLOOP:	ISZ	MPTR	;FOR EACH WORD
	LDA	1,MPTR
	LOAD	
	MOV	0,2
	MOVS	0,0
	LDA	1,RBMSK
	DSZ	SLEN
	AND	1,0,SNR
	JMP	SPR1	;DONE IF LEFT CHAR NULL
	JSR	@.TPUT
	MOV	2,0
	DSZ	SLEN
	AND	1,0,SNR
	JMP	SPR1	;DONE IF RIGHT CHAR NULL
	JSR	@.TPUT
	JMP	WLOOP
SPR1:	LDA	0,SPACE	;END WITH A SPACE
	JSR	@.TPUT
	JMP	RESTR
SLEN:	0
MPTR:	0
;
SAVER:	STA	0,SAV0	;SAVE REGS 0-2
	STA	1,SAV1
	STA	2,SAV2
	JMP	0,3
RESTR:	LDA	0,SAV0	;RESTORE AND RETURN
	LDA	1,SAV1
	LDA	2,SAV2
	JMP	@SAV3
SAV0:	0 
SAV1:	0 
SAV2:	0 
SAV3:	0 
;
;	/* ERROR DUMP */
ERR:	STA	3,SAV3X	;PRINT AC'S IN OCTAL
	JSR	POCTC
	MOV	1,0
	JSR	POCTC
	MOV	2,0
	JSR	POCTC
	LDA	0,SAV3X
	JSR	POCTC
	JSR	@.QERR
	.TXT	"... sorry, I got confused.<15>"
SAV3X:	0
;
;	/* PRINT */
PRIN1C:	JSR	@.FECH
	SNL	0,0
	JSR	POCTC
	JMP	@.ERET
;
CRLFC:	STA	3,SAV3	;DO A CARRIAGE RETURN 
	JSR	SAVER
	LDA	0,CR
	JSR	@.TPUT
	JMP	RESTR
;
;	/* USER LOOP (PRINT EVAL READ) */
USERLC:	LDA	0,VALUE	;*PRINT
	JSR	POCTC
	JSR	CRLFC
	LDAF	ARG0	;FREE PREV LIST
	JSR	@.REFD
	NIL	0,0	;GET RID OF OLD READLIST
	STAF	ARG0
	JSRII	.READ	;*READ
	STAF	ARG0
	INC	0,0
	STAF	PC	;*EVAL
	JMP	@.EVAL
;
;	/* READ */
READ1C:	JSRII	.READ
	JSR	@.SVLI
	JMP	@.ARET
.READ:	READ
;// 	/* READ FROM TTY */ 
;// 	CALLING SEQUENCE: 
;// 	JSR	TTRD
;// 	BUFFADR(BYTE) 
;// 	...	RETURN HERE 
TTRDR:	0	;// RETURN FOR TTRD
TTRDC:
	LDA	1,0,3		;// PICK UP PASSED BUFFER ADDRESS
	STA	1,BUFPT		;// INSTALL A LOCAL COPY 
;//	LDA	1,1,3	;// PICK UP ROUTINE TO CLEAR BUFFER
;//	STA	1,.RED1C	;//	SAVE IT
;//	INC	3,3
	INC	3,3
	STA	3,TTRDR
	ZER	1,1
	STA	1,COLNO		;// INITIALIZE COLUMN INDEX TO 0 FOR TABBING 
	ONE	1,1
	STA	1,PLEV		;// INIT PAREN LEVEL: 1 MEANS 0
RDNXT:
	JSR	@.TGET		;// CHAR TO AC0
	JSR	@.INDX		;// SCAN FOR SPECIAL CHARACTERS
	X1-.-1
ASCLP:	50	;// LPAR
ASCRP:	51	;// RPAR
	15	;// CR 
	177	;// RUBOUT
ASCBS:	10	;// BACKSPACE
	0	;// NULL
	12	;// LF
	11	;// TAB
	134	;// BACKSLASH 
APOS:	47	;// APOSTROPHE
X1:	JSR	.+1	;// GET PC
	ADD	2,3	;// ADD DISPATCH NUMBER
	JMP	3,3	;// STARTING WITH -1

	JMP	STIK	;// -1
	JMP	LPIN	;//  0
	JMP	RPIN	;//  1
	JMP	CRIN	;//  2
	JMP	RUBIN	;//  3
	JMP	RUBIN	;//  4
	JMP	RDNXT	;//  5
	JMP	RDECO	;//  6
	JMP	RDECO	;//  7
	JMP	KILIN	;//  8
	JMP	COMNT	;//  9
STIK:	LDA	2,COLNO	;// TEST COLUMN NUMBER
	LDA	3,MAXCOL
	SLT	2,3	;// SKIP COL < MAXIMUM
	JMP	REJECT	;// FULL, REJECT CHARACTER
	JSR	@.STIK		;// ENTER CHAR INTO BUFFER 
	BUFPT-.
	ISZ	COLNO		;// STEP COLUMN INDEX
RDECO:	JSR	@.TPUT		;// ECHO CHARACTER TYPED 
	JMP	RDNXT		;// GO BACK FOR MORE 
MAXCOL:	177	;// 127 CHARACTERS ON A LINE MAXIMUM (BUFFER SIZE)
RUBIN:
	LDA	1,COLNO	;// CHECK LEFT MARGIN
	SNZ	1,1
	JMP	RDNXT
	DSZ	BUFPT	;// UNBUMP POINTER
	DSZ	COLNO
	NOP
	;// CHECKING FOR BACKSPACE OVER PARENTHESIS (CHANGES COUNT)
	JSR	@.PICK	;// GET THE CHAR FROM BUFFER, IN AC0
	BUFPT-.
	NOP
	DSZ	BUFPT	;// MOVE POINTER BACK AGAIN
	LDA	1,ASCLP	;// LEFT PAREN
	SNE	0,1	;// SKIP IF NOT LEFT PAREN
	DSZ	PLEV	;// WAS, DECREMENT COUNT
	LDA	1,ASCRP	;// RIGHT PAREN   (PLEV NEVER ZERO)
	SNE	0,1	;// SKIP IF NOT RIGHT PAREN
	ISZ	PLEV	;// ERASED RIGHT PAREN,  INCREMENT COUNT
	LDA	0,ASCBS	;// ECHO BACKSPACE
	JMP	RDECO
LPIN:
	ISZ	PLEV		;// INCREMENT PAREN LEVEL
	JMP	STIK
RPIN:	DSZ	PLEV		;// DECREMENT PAREN LEVEL
	JMP	STIK
	ISZ	PLEV
REJECT:	LDA	0,BELL		;// ECHO BELL IF BELOW BOTTOM
	JSR	@.TPUT
	JMP	RDNXT
BELL:	7		;// RING-A-DING DONG
CRIN: 
	ZER	1,1		;// ZERO 
	STA	1,COLNO		;// THE COLUMN COUNTER 
	ZER	0,0
	JSR	@.STIK		;// TERMINATE STRING WITH NULL BYTE 
	BUFPT-.
	JSRII	.RED1C	;// CLEARS CHAR BUFFER AND RETUSNS NEW BUFPT AC0
	STA	0,BUFPT	;// STORE NEW BUFPT (RESET TO BEGINNING)
	JSRII	.CLF		;// ECHO THE CR
	LDA	0,PLEV		;// TEST PAREN LEVEL
	MOVZR	0,0,SNR
	JMP	@TTRDR	;// RETURN IF AT TOP LEVEL
	LDA	0,BLANK
	JSR	@.TPUT
	JSR	@.TPUT		;// INDENT CONTINUATION LINES
	JMP	RDNXT
.RED1C:	RED1
.CLF:	CRLF
KILIN:
	JSR	@.TPUT		;// ECHO THE BACKSLASH 
	JSRII	.CLF
	LDA	3,TTRDR	;// RELOAD RETURN
	NEG	3,3		;// RESET TO ENTRY VALUE 
	COM	3,3		;// AND START ALL OVER 
;//	NEG	3,3
;//	COM	3,3
	JMP	TTRDC
COMNT:			;// SCAN OVER STRINGS
	JSR	@.TPUT
	JSR	@.TGET
	LDA	1,APOS
	SEQ	0,1
	JMP	COMNT
	JMP	RDECO
CCNT:	0 
BLANK:	40
BUFPT:	0	;// BUFFER POINTER
COLNO:	0	;// COLUMN INDEX
PLEV:	0	;// PAREN LEVEL
;//  
;// 	/* RATOM */ 
;// 	JSR	RATOM		;// WITH BYTE POINTER IN AC2
;// 	...	...		;// INTERN RETURNED IN AC0
RATOM:	STA	2,RATPT		;// SET BUFFER POINTER 
	STA	3,RATX		;// SAVE RETURN
	LDA	3,@.TOKW
	INCZL	3,3		;//	FIX INTO BYTE PTR
	STA	3,TOKPT
PICK:	JSR	@.PICK		;// GET FIRST CHAR 
	RATPT-.
	ADC	0,0,SKP		;// RETURN -1 IF END OF INPUT
	SKIP 
	JMP	@RATX 
	JSR	LETCK
	JMP	ID		;// ITS A LETTER
	JSR	DIGCK
	JMP	NUM		;// ITS A DIGIT
	LDA	1,BLANK
	SNE	0,1
	JMP	PICK		;// PASS OVER BLANKS
	MOVS	0,0		;// SPL CHAR - SWAP TO MAKE IT
	STA	0,TOKENB+1		;//     A STRING OF LENGTH 1 
	ONE	1,1
	STA	1,TOKENB
INT:	LDA	2,@.TOKW		;// INTERN IT AS AN ATOM
	JSR	JINTB
RATRET:	LDA	2,RATPT
	JMP	@RATX		;// AND RETURN
RATX:	0

ID:		;//   IDENTIFIER
	JSR	@.STIK		;// COPY INTO TOKEN BUFFER
	TOKPT-.
	JSR	@.PICK 
	RATPT-.
	JMP	ENDAT		;// IF END OF INPUT
	JSR	LETCK
	JMP	ID		;// AS LONG AS WE FIND LETTERS
	JSR	DIGCK
	JMP	ID		;// OR DIGITS 
ENDAT:	ZER	0,0		;// END OF ATOM
	JSR	@.STIK		;// TERMINATE WITH NULL 
	TOKPT-.
	LDA	0,TOKPT
	LDA	1,@.TOKW
	INCZL	1,1		;// FIX INTO BYTE PTR
	ADC	1,0		;// GET TOKEN LENGTH
	STA	0,TOKENB
	DSZ	RATPT		;// BACKSPACE INPUT POINTER
	JMP	INT		;// INTERN AND RETURN
NUM:		;//   NUMBER 
	ZER	1,1		;// SET VAL = 0
	STA	1,VAL
	STA	1,SIGN
	LDA	2,C10
	LDA	1,C60
	SNE	1,0
	LDA	2,C8	;// 1ST DIGIT=0 ==> OCTAL
	STA	2,RADIXX
	LDA	1,C25		;CHECK FOR HIGH-MINUS
	SEQ	0,1
	 JMP	NNUM1		; NO
	ISZ	SIGN
	JMP	NNUM2
NNUM1:	LDA	1,C60 
	SUB	1,0		;// AC0 _ DIGIT VALUE
	STA	0,T4
	LDA	1,VAL
	ZER	0,0
	LDA	2,RADIXX
	JSR	@.MUL
	LDA	0,T4
	ADD	0,1
	STA	1,VAL		;// ADD TO GET NEW VALUE 
NNUM2:	JSR	@.PICK 
	RATPT-.
	JMP	ENDNM		;// IF END OF INPUT
	JSR	DIGCK
	JMP	NNUM1		;// LOOP AS LONG AS NEXT CHAR IS DIGIT
ENDNM:	LDA	2,VAL
	LDA	1,SIGN
	SZE	1,1
	 NEG	2,2		;NEGATE IF WAS MINUS
	STA	2,VAL
	LDA	1,C56		;NOW PEEK FOR .0
	SEQ	0,1
	JMP	NO1
	JSR	@.PICK
	RATPT-.
	JMP	NO2
	LDA	1,C60
	SNE	0,1
	JMP	FLOAT
NO2:	DSZ	RATPT
NO1:	DSZ	RATPT
	LDA	0,VAL
	JSR	@.INTN		;// INTERN NUMERIC VALUE
	JMP	RATRET 
FLOAT:	LDA	1,VAL		;***FLOAT IT HERE
	ZER	0,0
	JSRII	.FLDI
	ZER	0,0
	JSRII	.FST
	JMP	RATRET
.FLDI:	FLDI
.FST:	FST
SIGN:	0
C25:	25
C10:	12
C56:	56
C8:	10
RADIXX:	0
VAL:	0
T4:	0
RATPT:	0	;// RATOM'S POINTER INTO TTI BUFF 
.TOKW:	.TOKENB	;// TOKEN WORD ADDR (STATIC)
TOKPT:	0	;// RATOM'S POINTER TO TOKEN
JINTB:	JMP	INTB	;LONG JUMP;//  
LETCK:		;// RETURN 0,3 IF AC0 HOLDS A LETTER, ELSE 1,3 
	LDA	1,C100
	SGT	0,1
	JMP	1,3	;//  < "A"
	LDA	1,C132 
	SGT	0,1
	JMP	0,3	;//  <= "Z" 
	LDA	1,C141 
	SGE	0,1
	JMP	1,3	;//  < "a" 
	LDA	1,C172 
	SGT	0,1
	JMP	0,3	;//  <= "z"
	JMP	1,3	;//  > "z" 
DIGCK:		;// RETURN 0,3 IF AC0 HOLDS A DIGIT, ELSE 1,3
	LDA	1,C25
	SNE	0,1
	JMP	0,3	;//  HIGH-MINUS IS "DIGIT"
	LDA	1,C60
	SGE	0,1
	JMP	1,3	;//  < "0"
	LDA	1,C71
	SGT	0,1
	JMP	0,3	;//  <= "9" 
	JMP	1,3	;//  > "9"
TOKENB:	.BLK	40	;// TOKEN BUFFER
C60:	60
C71:	71
C100:	100
C132:	132
C141:	141
C172:	172
.POCT:	POCT
;//  
;// 	/* ATOM INTERN */ 
;// 	JSR	INTB		;// AC2 -> TOKEN, RESULT IN AC0
INTB:	STA	2,INT4		;// SAVE TOKEN ADDR
	STA	3,INT2 
	JSR	HASH		;// HASH THE TOKEN
LOOK:	STA	1,INT1
	LOAD			;// LOOK IN THAT CELL 
	SNN	0,0
	JMP	INSTL		;// BRANCH IF EMPTY
	STA	0,PNAME
	INC	0,1
	LOAD
	STA	0,INT3	;// PNAME LEN
	ZER	0,0
	STA	0,PNPTR
	LDA	0,@.TOKW
	INCZL	0,0		;// FIX INTO BYTE PTR
	STA	0,TOKPT
COMPR:	JSR	@.PICK	;// COMPARE PNAME TO STRING
	TOKPT-.
	NOP
	STA	0,TMP
	JSR	@.GNB
PNPTR:	0
PNAME:	0
	LDA	1,TMP
	SEQ	0,1
	JMP	NEQ
	DSZ	INT3
	JMP	COMPR
	JMP	EQL
TMP:	0
NEQ:	LDA	1,INT1		;// NO MATCH
	INC	1,1		;// REHASH 
	LDA	0,MXATM
	AND	0,1
	JMP	LOOK		;// AND TRY AGAIN 
INSTL:		;// INSTALL NEW NAME IN MEM, AND PTR IN ATOM CELL
	LDA	0,@INT4		;// GET LENGTH
	INCZR	0,0		;// NWORDS
	INC	0,0
	STA	0,INT3		;// NWORDS INCL LENGTH
	INC	0,0		;// PLUS 1 FOR TYPE
	JSR	@.LALO		;// ALLOCATE STRING
	STA	2,SPTR
	MOV	2,0
	LDA	1,INT1
	STOR		;// ATOM CELL_POINTER
	MOV	0,1
	LDA	0,SCLAS
	STOR		;// TYPE_STRING
CPYT:	LDA	0,@INT4		;// COPY FROM BUFFER TO STRING
	ISZ	INT4
	ISZ	SPTR
	LDA	1,SPTR
	STOR		;// STRING WORD_BUFFER WORD
	DSZ	INT3		;// COUNT WORDS
	JMP	CPYT 
	JMP	EQL	;// SKIP PRINTOUT
	LDA	0,INT1
	JSRII	.SPRT	;// PRINT NAME
	JSRII	.POCT	;// PRINT ADDR
EQL:		;// RETURN THE INTERNED VALUE
	LDA	0,INT1 
	JMP	@INT2
.CRLF:	CRLF
.SPRT:	SPRT
SPTR:	0
ZET:		;// TEST STRING END (NULL BYTE IN AC1) 
	LDA	2,RBMSK
	AND#	2,1,SNR 
	JMP	1,3		;// IF RIGHT BYTE NULL 
	COM	2,2
	AND#	2,1,SNR 
	JMP	1,3		;// IF LEFT BYTE NULL
	JMP	0,3		;// IF NO STRING END 
;// TEMPS		;// ATOM INTERN           NUMERIC INTTERN
INT1:	0	;// INTERN INDEX          RETURN 
INT2:	0	;// RETURN 
INT3:	0	;// TOKEN POINTER
INT4:	0	;// TOKEN POINTER SAVE 
;//  
;// 	/* STRING HASH */ 
;// 	CALLING SEQUENCE: 
;// 	JSR	HASH	;// AC2 = WORD ADDR OF STRING BUFF
;// 	...	...	;// HASH IN AC1 - REST CLOBBERED 
HASH:	STA	3,HSRET 
	INC	2,2
	ZER	3,3
	LDA	1,RBMSK
HLOOP:	LDA	0,0,2		;// PICK UP NEXT TWO CHARS 
	COM	1,1
	ANDZS	0,1,SNR		;// TEST TOP BYTE FOR NULL 
	JMP	HEND 
	ADDS	0,1
	ADDL	1,1 
	ADD	0,1		;// AC1 _ HASH, AC0 NOT DISTURBED
	ADD	1,3		;// HASH _ SUM OF THESE
	LDA	1,RBMSK
	INC	2,2
	AND	1,0,SZR		;// TEST BOTTOM BYTE FOR NULL
	JMP	HLOOP
HEND:	LDA	1,MXATM 
	AND	3,1
	JMP	@HSRET 
HSRET:	0
;//  
;// 	/* READ */	;// LIST POINTER RETURNED IN AC0
;//   RED1C CLEARS CHARACTES BUFFER AND FILLS ATOM BUFFER.
;//    GIVES BACK NEW BUFPTR IN AC0.   (BELL TWICE AND RUNS
;//    WHaT IT HAS IF ATOM BUFFEZ FULL).
RED1RT:	0	;// RED1C RETURN ADDR
RED1C:	STA	3,RED1RT	;// SAVE RETURN
	LDA	2,.RDBF		;// SET UP BUFFER POINTER
	STA	2,TEMP 
RED11:	LDA	2,TEMP 
	JSRII	.RATM
	STA	2,TEMP 
	INC#	0,0,SNR		;// TEST FOR -1 TERMINATOR
	JMP	RED12
	STA	0,@INCPT		;// COPY FROM RATOM INTO BUFFER 
	ISZ	INCPT
	JMP	RED11
RED12:	LDA	0,.RDBF	;// RESET CHAR BUFFER
	LDA	1,INCPT
	LDA	2,@.IBMAX
	SGE	1,2	;// SKIP OVERFLOW OF ATOM BUFFER
	JMP	@RED1RT	;// RETURN
	JSR	@.QERR
	.TXT	"Buffer overflowed."
.IBMAX:	RDBUFS	;// TOP OF ATOM BUFFER
.RATM:	RATOMS
TEMP:	0
INCPT:	0
.TTRD:	TTRD
C55:	55
C76:	76
;// 
;//	/* SMALLTALK READ */
READC:		;// MUST BE BUFFERED DUE TO ALLOC OF PNAMES 
	STA	3,REDRT
;// 	JSR	@.COFF	;// ***FOR TIMING
	LDA	0,C55
	JSR	@.TPUT
	LDA	0,C76
	JSR	@.TPUT
	LDA	0,@.IBUF
	STA	0,INCPT		;// BEGIN BUFFER 
	LDA	0,@.IBMAX	;// BYTE PTR TO RDBUF
	MOVZL	0,0	;// *2
	STA	0,.RDBF
	JSRII	.TTRD	;// READ TTY INTO BUFFER
.RDBF:	0		;// BUFFER BYTE PTR
;//	RED1C		;// NO LONGER OPTIONAL
READ2:	LDA	0,RPAR		;// END WITH RIGHT PAREN
	STA	0,@INCPT 
	ISZ	INCPT
	NIL	0,0		;// AND AN ENDFLAG (-1)
	STA	0,@INCPT 
	LDA	1,@.STAK
	STA	1,STAKPT	;// INIT SUBLIST STACK W/NIL
	STA	0,@STAKPT
	STA	0,FIXUP		;// SAME W/FIXUP
	LDA	1,@.IBUF		;// RESET INCPT TO START OF BUFFER
	STA	1,INCSV
;// 	/* MAKE UP A LIST, PUSHING SUBLISTS ONTO STACK
MAKLIS:	LDA	0,INCSV		;// INIT ATOM PTR
	STA	0,INCPT
	ZER	0,0		;// AND VECTOR LENGTH
	STA	0,VLEN
	LDA	0,LSCLA		;// OUPUT LIST HEADER
	JSR	P2P
	LDA	0,LENG		;// AND LENGTH (KNOWN ON PASS 2)
	JSR	P2P
MAKLP:	LDA	0,@INCPT
	ISZ	INCPT		;// PICK UP NEXT TOKEN
	LDA	1,LPAR
	SNE	0,1		;// TEST "(
	JMP	LPARS
	LDA	1,RPAR
	SNE	0,1		;// TEST ")
	JMP	RPARS
	JSR	P2P		;// UNSPECIAL - OUTPUT TOKEN
	JMP	MAKLP
LPARS:	;// /* SCAN OVER SUBLIST
	LDA	1,PASS
	SNZ	1,1
	JMP	LP1
	LDA	0,VECB		;// ON PASS 2
	LDA	1,VLEN
	ADD	1,0
	ISZ	STAKPT		;// PUSH ADDR TO BE FIXED UP (SUBLIS PTR)
	STA	0,@STAKPT
	LDA	0,INCPT		;// SAVE SCAN PTR IN THIS CELL
LP1:	JSR	P2P
	ONE	1,1
	STA	1,PARCT
	LDA	1,LPAR
	LDA	2,RPAR
SCAN:	LDA	0,@INCPT	;// SCAN TO MATCHING ")
	ISZ	INCPT
	SNE	0,1
	ISZ	PARCT
	SEQ	0,2
	JMP	SCAN
	DSZ	PARCT
	JMP	SCAN
	JMP	MAKLP
RPARS:	;// /* TERMINATE LIST AND RETURN POINTER
	NIL	0,0		;// APPEND NIL
	JSR	P2P
	LDA	1,PASS
	COM	1,1
	STA	1,PASS		;// CHANGE PASS #
	SNZ	1,1
	JMP	RP1
	LDA	0,VLEN		;// END OF PASS 1
	STA	0,LENG
	DSZ	LENG
	DSZ	LENG
	JSR	@.LALO		;// ALLOCATE LIST
	MOV	2,0
	STA	0,VECB
	LDA	1,FIXUP		;// RESOLVE REF TO THIS LIST
	SNN	1,1
	STA	0,RDPTR
	SNL	1,1
	STOR
	JMP	MAKLIS
RP1:	LDA	1,@STAKPT		;// END OF PASS 2
	DSZ	STAKPT
	SNN	1,1		;// TEST DONE
	JMP	READ4
	STA	1,FIXUP		;// NO, GET NEXT SUBLIST FROM FIXUP
	LOAD
	STA	0,INCSV
	JMP	MAKLIS
READ4:
;// 	JSR	@.CON	;// ***FOR TIMING
	LDA	0,RDPTR		;// POINT TO LIST AND RETURN 
	JMP	@REDRT 
RPAR:	QRPAR
LPAR:	QLPAR
;//	.CON:	CLKON	;// FOR TIMING
;//	.COFF:	CLKOFF
;// 
;// 	/* TWO-PASS PUT
P2P:	STA	3,P2RT
	LDA	1,PASS
	SNZ	1,1
	JMP	P2P1
	LDA	1,VLEN	;// PASS 2 - STORE INTO VECTOR
	LDA	2,VECB
	ADD	2,1
	STOR
P2P1:	ISZ	VLEN	;// BOTH PASSES - STEP VECTOR INDEX
	JMP	@P2RT
P2RT:	0
;// 
INCSV:	0
VLEN:	0
LENG:	0
VECB:	0
PASS:	0
STAKPT:	0
REDRT:	0	;// RETURN SAVE 
RDPTR:	0	;// ADDRESS OF READ-LIST SAVED HERE 
.IBUF:	IBUFS	;// BUFFER ORIGIN
FIXUP:	0
PARCT:	0
.STAK:	STACKS
STACK:	.BLK	40	;// LIMIT 32-DEEP PARENS
IBUF:	.BLK	1400	;// TOKEN BUFFER
RDBUF:	.BLK	100	;// TTY BUFFER 
; 
;	JSR 	PICK 
;	rel loc of byteptr, as BUFPT-.
;	END-OF-STRING RETURN
;	...	...		;CHAR IN AC0;  AC2 WILL BE CLOBBERED 
PICKC:	INC	3,2
	STA	2,HOLD1
	LDA	3,0,3
	ADD	2,3		;[AC3] _ 1+LOC(BUFPT)
	LDA	2,-1,3		;GET BYTE POINTER
	ISZ	-1,3		;STEP IT
	JSR	GBYT		;GET THE BYTE
	SZE	0,0		;FIRST RET IF ZERO
	ISZ	HOLD1		;ELSE SECOND
	JMP	@HOLD1		;RETURN
; 
;	JSR	STICK		;CHAR IN AC0 
;	REL LOC OF BYTEPTR (AS WITH PICK)
;	...	...		;AC1 AND AC2 CLOBBERED 
STIKC:	INC	3,2
	STA	2,HOLD1
	LDA	3,0,3
	ADD	2,3		;[AC3] _ 1+LOC(BUFPT)
	LDA	2,-1,3		;GET BYTE POINTER
	ISZ	-1,3		;STEP IT
	JSR	PBYT		;PUT THE BYTE
	JMP	@HOLD1		;RETURN
; 
;	JSR	GBYT		;BYTEPOINTER IN AC2 
;	...	...		;CHAR IN AC0, AC2 CLOBBERED
GBYT:	MOVZR	2,2 
	LDA	0,0,2		;FETCH WORD 
	MOV	0,0,SNC
	MOVS	0,0		;SWAP IF LEFT BYTE 
	LDA	2,RBMSK 
	AND	2,0		;KILL HIGH BYTE 
	JMP	0,3		;RETURN 
; 
;	JSR	PBYT		;CHAR IN AC0, BYTEPOINTER IN AC2
;	...	...		;AC1 AND AC2 CLOBBERED 
PBYT:	MOVZR	2,2 
	STA	2,HOLD0		;SAVE WORD ADDR 
	LDA	2,0,2		;FETCH WORD 
	LDA	1,RBMSK 
	AND	1,0,SNC		;KILL HIGH BYTE AND TEST
	MOVS	2,2		;SWAP WORD IF LEFT BYTE
	COM	1,1
	AND	1,2,SNC		;CLEAR THE BYTE AND TEST
	ADDS	0,2,SKP		;OR AND UNSWAP IF LEFT 
	ADD	0,2		;JUST OR IF RIGHT 
	STA	2,@HOLD0	;STORE IT 
	JMP	0,3		;AND HEAD FOR HOME
HOLD0:	0
HOLD1:	0
	.END
