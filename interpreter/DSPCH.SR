
;//FILE MAINTENANCE --    DSPCH.SR
;//DISPATCH ROUTINE FOR SCAN CONVERSION SUBROUTINES.
;//THAT IS, DSPTCHNG DONE ON BASIS OF NO. PRECEDING CODE ESCAPE
;//0 = APPEND STRING OR CHAR(DODSP)
	;//CHECKS TO SEE IF INPUT STRING OR CHARACTER.
	;//IF STRING APPEND IT TO FRAME BUFFER--SCROLL UP IF 
	;//NECESSARY TO GET ALL OF STRING IN.  THE SCROLLING
	;//IS A STRPING OFF OF THE TOP LINE IN THE FRAME BUFFER,
	;//DOING OF BLK MOVE AND CLR FROM THE SECOND LINE TO THE
	;//BTM OF THE FRAME/WINDOW UP AND RESCANNING THE OLD LAST
	;//LINE AT THE APPRPRTE Y AND A NEW LAST LINE. THIS WILL
	;//REPEAT UNTIL THE INPUT STRING IS EXHAUSTED.
	;//FOR CHARACTER INPUT, THE CHAR IS ADDED TO THE FRAME
	;//BFR AND THE SCANNING IS BEGUN FROM THE BGNNG OF THE
	;//LAST LINE IN THE BFR--OVERFLO OF THE BTM OF THE WINDOW
	;//WILL CAUSE SCROLLING AS ABOVE.

	;//CHECKS WINDOW AND FRAME PARAMETERS FOR LEGALITY --
	;//IS THE WINDOW ON THE DISPLAY? -- AND FOR INTERSECTION
	;//THE LNGTH OF LINES ARE DTRMNED ON THE BASIS OF FRAME
	;//PARAMETERS, BUT SCAN CONVERSION ONLY OCCURS WHERE THE
	;//FRAME AND WINDOW INTERSECT. WORD WRAP AROUND IS DONE
	;//ON THE BASIS OF THE FRAME PARAMETERS.
	;//"LAST" IS BYTE PTR TO LAST GOOD CHAR IN BUFFER AND
	;//IS WHERE APPENDING BEGINS.  THIS BYTE PTR IS NEEDED
	;//SINCE ANY 8-BIT CODE MAY BE A LGAL CHAR & NO TRPNG IS
	;//DONE FOR A TERMINATING CHARACTER.
	;//REPLIES:
	;//0 MEANS THERE WAS INTERSECTION AND THE STRING
		;//WAS SCNED IN WITHOUT CHANGING THE HGHT OF THE
		;//FRAME OR OVERFLOWING THE BOTTOM OF THE WINDOW
	;//1 MEANS THAT THERE WAS NO INTERSECTION BETWEEN THE
		;//THE WINDOW AND THE DSP--IF THE WINDOW SOMEHOW
		;//EXCEEDS THE LARGEST POSSIBLE DISP PARAMS, ITS
		;//(THE WNDO'S) PARAMS WILL BE INTRNLY MODIFIED
		;//TO FIT WITHIN THE DISPLAY.
	;//2 MEANS THERE IS NO INTERSECTION BETWEEN THE WINDOW
		;//AND THE FRAME
	;//3 MEANS NO ROOM FOR LINE OF TEXT IN WINDOW
	;//4 MEANS THAT THE HEIGHT OF THE FRAME HAS BEEN MADE
		;//LARGER TO ACCOMODATE THE STRING.
	;//5 MEANS THE BOTTOM OF THE WINDOW HAS BEEN OVERFLOWED
		;//INDICATES THAT SCROLLING TOOK PLACE.
	;//6 MEANS THAT BOTH THE HEIGHT OF THE FRAME HAS BEEN
		;//INCREASED AND THE BTM OF THE WINDO OVRFLOED.
;//1 = CLEAR
	;//PUTS BFR BYTE PTR BACK TO BGNING AND CLEARS THE FRAME
;//3 = SHOW
	;//MEANS TO SCAN CONVERT THE FRAME BFR FROM BEGINNING TO
	;//"LAST" BYTE PTR
;//2 = SCROL
	;//CAUSES TOP LINE TO BE STRIPPED OFF BFR AND REMAINDER
	;//TO BE MOVED UP ONE LINE AS DESCRIBED FOR 0 ABOVE
;//4 = CLEAR FRAME (FCLER)
	;//REPLIES:
		;//0 MEANS INSCTN BETWEEN WNDO AND FRM & CLRING
		;//DONE ON THAT BASIS
		;//1 MEANS NO INTRSCTN BETWEEN WINDOW AND DISPLAY
		;//2 MEANS NO INTRSCTN BETWEEN WINDOW AND FRAME
;//5 = CLEAR WINDOW(WCLER)
		;//0 MEANS INSCTN BETWEEN WINDO AND DSP & CLRING
		;//DONE ON THAT BASIS
		;//1 MEANS NO INTRSCTN BETWEEN WINDO AND DISPLAY

;//6 = FIND TOKEN
	;//TAKES TWO ARGS - X AND Y (TYPICALLY MSEX AND MSEY)
	;//RETURNS VECTOR 
		;//VEC[1] = TOKCNT
		;//VEC[2] = LEFT X OF TOKEN
		;//VEC[3] = WIDTH OF TOKEN
		;//VEC[4] = TOP Y OF TOKEN
;//8 = FIND WORD
	;//TAKES TWO ARGS - X AND Y (TYPICALLY MSEX AND MSEY)
	;//RETURNS VECTOR 
		;//VEC[1] = SUBSCRIPT OF FIRST CHAR
		;//VEC[2] = LEFT X OF WORD
		;//VEC[3] = WIDTH OF WORD
		;//VEC[4] = TOP Y OF WORD

;//7 = FIND CHAR
	;//TAKES TWO ARGS - X AND Y (TYPICALLY MSEX AND MSEY)
	;//RETURNS VECTOR 
		;//VEC[1] = SUBSCRIPT OF CHAR IN STRING
		;//VEC[2] = LEFT X OF CHAR
		;//VEC[3] = WIDTH OF CHAR
		;//VEC[4] = TOP Y OF CHAR

;//A -1 REPLY MEANS THAT DSPCH HAS BEEN CALLED WITH AN 
;//UNIMPLEMENTEDMODE VALUE.

.TITL DSPCH
.GETNOLIST "SMALL.OPS"
.GETNOLIST "SMALL.SYMS"
.GETNOLIST "SMDISP.SYMS"

.SREL
DSPCH:	DSPCHC
GOTMS:	GOTMSC
CHKMS:	CHKMSC
STRMD:	400
BFCON:	10
MOOD:	0
MSEX:	0
MSEY:	0
MCHRS:	0
MTOKS:	0
MWRDS:	0
MSESW:	0
RTNC:	0
RTNX:	0
RTNY:	0
RTNW:	0


JMPTB:	JMPTBA
SHOW:	SHOWC
DODSP:	DODSPC
CLEARS:	CLEARC
UNIMP:	UNIMPC
FDTOK:	FDTOKC
FDCHR:	FDCHRC
FDWRD:	FDWRDC
SSTBL:	1
	5
	0
DBUF:	0
DSLB:	0
DSRB:	0
INPT:	0
INLB:	0
INRB:	0

.NREL

-1
DSPCHC:
	LDA 0,VALUE	;//DISPATCH ACCORDING TO INTEGER
	JSR @.IVAL	;//PRECEDING CODE ESCAPE
	LDA 2,@.JPTB
	ADDZ 0,2
	LDA 2,0,2	;//AND DOWN ONCE MORE
	JMP @0,2

.JPTB:	JMPTB
.BFCON:	BFCON		;//VALUE FOR TSTNG SPC LEFT IN FRAME BUF

DODSPC:
	JSRII .GTIN	;//GET INSTANCE VARIABLES INTO CORE TABLE
	JSRII .CKPR	;//FIND OUT WHAT REAL SCAN CONV. PARAMS 

	JSR @.FECH	;//GET INPUT
	STA 0,@.INPT
	JSR @.ISIT	;//ISIT COMPARES AGAINST INLINE THING
	SCLAS
	JMP DOCHR
	INC 0,1	;//IT'S A STRING--WE HOPE
	LOAD
	STA 0,SLEN	;//IF IT TURNS OUT A STRING--SAVE LENGTH

	ZER 0,0		;//INIT STPNG SWCH WHEN INPT IS STRING
	STA 0,ENDS
	STA 0,@.INRB	;//INIT IN RIGHT BND
	STA 0,@.WNOV	;//AND WINDOW OVERFLOW SWITCH

	LDA 0,@.BUF	;//GET STRING PTR SET UP FOR SSCAN
	STA 0,@.DBUF
	LDA 0,@.BFLN	;//(BUF LEN-LAST)>INPUT LEN?
			;//(ONLY ONE STG FIX)
	LDA 1,@.LAST	
	SUBZ 1,0
	LDA 2,SLEN
	SLE 2,0
	JMP NOFIT
	MOVZ 1,3	;//LAST--NOT LAST+1--NEEDED FOR
			;//GETTING DSRB AND NEW LAST
	INC 1,1
	STA 1,@.DSLB	;//DES LEFT BND IS OLD LAST+1
	ADDZ 2,3	;//HERE'S ONE TIME SETUP
	STA 3,@.DSRB	;//LAST IS DES LFT BND--LAST+INPUT LEN IS
	STA 3,@.LAST	;//SAVE LAST
	ONE 0,0		;//DES RIGHT BOUND
	STA 0,@.INLB
	STA 2,@.INRB	;//INPUT LENGTH IS SOURCE RIGHT BOUND
	ISZ ENDS	;//SET END SWITCH
	STA 0,@.MOOD	;//SETUP MODE SWCH FOR NO CLR ON SCNG
	JMP STRFX

NOFIT:
	ONE 0,0		;//ONE IS WHERE IS INLB STARTS
	STA 0,@.INLB
	STA 0,@.MOOD
STRLP:
	LDA 2,SLEN	;//THE AMT OF STRING GRABBED EACH TIME IS
	LDA 0,@.BFLN	;//BUF LGTH - LAST, BUF LGTH, OR BUF LGTH
	LDA 1,@.LAST	;//- LAST AFTER A SCROLL
	SUBZ 1,0
	INC 1,1		;//LAST+1 IS DSLB UNLESS FIXED BY LITBUF
	STA 1,@.DSLB
	LDA 3,@.BFLN	;//IF BFR LNGTH SHRTER THAN INPUT STRG
	LDA 1,@.BFCON	;//OR SPC IN BFR IS SMALL
			;//(SMALLER THAN BUFCON, SAY)
	SLT 0,1		;//THEN LITBUF RTN MAKES SOME RSNBLE AMT
	SGT 3,2		;//OF SPACE AVAILABLE
			;//I.E. A FRAME WIDTH'S WORTH OR THE
			;//LGTH OF THE BFR, WHICHEVER IS LESS AND
			;//SCRLNG OCCURS ON THE BASIS OF THE BFR
			;//AS OPPOSED TO WINDOW OVERFLOW
	JSR LITBF
	STA 0,DECVL	;//FRST-TIME STUP FOR STRGS>BUF LEN-LAST
	LDA 2,@.INRB	;//AND OLD INRB+DECVL IS NEW INRB UNLESS
	ADDZ 0,2	;//> INPUT LEN IN WHICH CASE INPUT LEN
	LDA 0,SLEN	;//IS RIGHT BOUNDARY
	SGT 0,2		;//AND DES RIGHT BND NEEDS FIXUP
	JMP LSTIM
	STA 2,@.INRB
	LDA 0,@.BFLN	;//SET UP DES RIGHT BND AND LAST
	STA 0,@.DSRB
	STA 0,@.LAST
STRFX:
	JSR @.SSCAN	;//DO BUFFER FIXUP
	SSTBL

	JSRII .UPDT	;//NON-NORMAL RTN--SHOULDN'T EVER HAPPEN
	JSRII .PSTG	;//SCN IN NEW STUFF BGNNG WITH LAST LINE
	LDA 0,ENDS	;//DONE
	SZE 0,0
	JSRII .UPDT	;//GO TO UPDATING
	LDA 0,DECVL	;//NOT DONE?--NEW INLB IS DEC VALUE 
			;//+ OLD INLB
	LDA 1,@.INLB
	ADDZ 0,1
	STA 1,@.INLB

	JMP STRLP

LSTIM:
	STA 0,@.INRB	;//ON LAST TIME INRB IS INPUT LENGTH
	LDA 1,@.INLB
	SUBZ 1,0	;//ON LAST TIME DSRB IS LAST+1+
	LDA 2,@.LAST	;//(INRB-INLB)
	INC 2,2
	ADDZ 0,2
	STA 2,@.DSRB
	STA 2,@.LAST	;//UPDATE LAST
	SUBZ 0,2	;//FINAL DSLB IS (LAST+1)-(INRB-INLB)
	STA 2,@.DSLB
	ISZ ENDS	;//SET ENDS SWITCH
	JMP STRFX	;//AND GO

.DBUF:	DBUF
.DSLB:	DSLB
.DSRB:	DSRB
.INPT:	INPT
.INLB:	INLB
.INRB:	INRB
.GTIN:	GTINS
.CKPR:	CKPAR
.PSTG:	PSTRG
.SCRL:	SCROL
.BUF:	BUF
.BFLN:	BFLN
.LAST:	LAST
.UPDT:	UPDAT
.WNOV:	WNOVR

ENDS:	0
SLEN:	0
.MOOD:	MOOD
DECVL:	0
BCSP:	10

DOCHR:
	JSR @.IVAL	;//HERE'S THE APPEND CHAR MODE
	STA 0,@.MOOD
	LDA 1,@.BUF	;//SET UP STRING PTR FOR PTB
	STA 1,PTBST
	LDA 1,@.LAST
	LDA 2,BCSP
	SNE 0,2
	JMP BCKSP
	INC 1,1
	LDA 2,@.BFLN	;//IF IN SHORT BUFFER CONDITION
	SLE 1,2		;//DO A SCROLL BEFORE PROCEEDING
	JSR DOSCL
	STA 1,@.LAST
	STA 1,NXCHR

	JSR @.PTB	;//UPDATE BUFFER
NXCHR:	0
PTBST:	0

CHROU:
	JSRII .PSTG
	JSRII .UPDT

BCKSP:
	SZE 1,1		;//IF LAST > ZERO DEC IT 
	DSZ @.LAST	;//OTHERWISE LEAVE IT ALONE
	JMP CHROU
	JMP CHROU

RTRN2:	0
LITBF:
	STA 3,RTRN2	;//ROUTINE FOR INADEQUATE BUFFER FIXUP
	JSRII .SCRL	;//DO A SCROLL
	LDA 1,@.LAST	;//IF LAST IS ZERO--
			;//MEANS NOT ENOUGH EVEN FOR
	SGZ 1,1		;//A FRAME WIDTH OF CHARS
	JMP TINY	;//SO DO SOME SPECIAL STUFF
	LDA 0,@.BFLN	;//ELSE SCROL WILL HAVE MADE SOME SPC
	SUBZ 1,0	;//AND WE'LL HAVE AN APPROPRIATE DECVL
	INC 1,1		;//FIXUP DES LEFT BND
	STA 1,@.DSLB
	JMP @RTRN2	;//FROM INPUT STRING
TINY:
	ONE 0,0		;//TNY MEANS AL WE HAV IS THE BFR SO ITS
	STA 0,@.DSLB	;//LENGTH IS OUR DEC VALUE AND 1 IS DSLB
	LDA 0,@.BFLN
	JMP @RTRN2
DOSCL:
	STA 3,RTRN2	;//FIX FOR SHORT BUFFER WHEN IN APPEND
	STA 0,SVCHR	;//SAVE INPUT
	JSRII .SCRL	;//CHARACTER MODE
	LDA 0,SVCHR	;//SCRL BMBS AC0 AND MODE--
			;//SO GT INPT BACK
	LDA 1,@.LAST	;//TINY BFR MEANS FIX REQUIRED FOR LAST
	INC 1,1
	JMP @RTRN2

SVCHR:	0
.STRMD:	STRMD

SHOWC:
	LDA 0,@.STRMD	;//DISP BFR FROM BEGINNING OF STRING
	STA 0, @.MOOD
	JSRII .GTIN	;//GET THE INSTANCE
	JSRII .CKPR	;//CHECK PARAMS FOR LEGALITY
	LDA 0,@.MSESW	;//SEE IF IN FIND MOUSE CALL
	SGZ 0,0		;//OR IF JST MSE CALL
	JMP NOMSE
CHKMSC:
	LDA 0,SPACE	;//ADD A SPACE WORTH OF WIDTH TO FRAME TO
	JSRII .GTWD	;//HANDLE PTING TO SPACE AT END OF LINE
	LDA 1,@.MSEX	;//SEE IF MOUSE WITHIN AREA BEING
	LDA 2,@.RELX	;//DISPLAYED
	LDA 3,@.RLWD
	ADDZ 0,3
	ADDZ 2,3
	SLT 1,2
	SLE 1,3
	JMP NTIN
	LDA 0,@.MSEY
	LDA 1,@.RELY
	LDA 2,@.RLHT
	ADDZ 1,2
	SLT 0,1
	SLE 0,2
	JMP NTIN
NOMSE:
	JSRII .PSTG	;//AND GO DO IT
	LDA 0,@.MSESW	;//CHECK FOR CALL FROM MOUSE
	SGZ 0,0
	JSRII .UPDT

	NIL 0,0		;//WHEN MOUSE IN FRAME BUT NOT ON 
	STA 0,@.RTNC	;//ANYTHING RETURN NIL
	JMP GOTMSC
OFFVL:	-2
NTIN:
	LDA 0,OFFVL	;//MSE NOT IN WINDOW OR OFF DISPLAY
	STA 0,@.RTNC	;//RETURN -2
	JMP GOTMSC


CLEARC:
	ZER 0,0
	JSR @.SINS	;//MAKE LAST ZERO
	LS
	ONE 0,0		;//MAKE LAST LINE BE ONE
	JSR @.SINS
	LL
	JSR @.LINS	;//MAKE CHAR Y FRAME Y
	FY
	JSR @.SINS
	CY
	JSRII .FCLR	;//CLEAR THE FRAME

UNIMPC:
	NIL 0,0		;//UNIMPLEMENTED MODE
	JSR @.SINS
	RP
	JMP @.EVAL

JMPTBA:
	DODSP
	CLEARS
	STSCL
	SHOW
.FCLR:	FCLER
	WCLER
	FDTOK
	FDCHR
	FDWRD
	UNIMP

SPACE:	40
.MSEX:	MSEX
.MSEY:	MSEY
.MCHRS:	MCHRS
.MTOKS:	MTOKS
.MWRDS:	MWRDS
.MSESW:	MSESW
.RELX:	REALX
.RLWD:	RELWD
.RELY:	REALY
.RLHT:	RELHT
.GTWD:	GETWD
.RTNC:	RTNC
.RTNX:	RTNX
.RTNW:	RTNW
.RTNY:	RTNY

FDWRDC:
	ISZ @.MWRDS	;//SET WORD LOOKING SWITCH
FDTOKC:
	ISZ @.MTOKS	;//SET TOKEN SWITCH
	JMP ALL
FDCHRC:
	ISZ @.MCHRS	;//SET FIND CHAR SWITCH
ALL:
	ISZ @.MSESW	;//COMMON CODE--SET MOUSE FIND SWITCH
	JSRII .GTMES	;//GET MOUSE X AND MOUSE Y
	2
	MSEX
	JMP SHOWC	;//DO SEARCH BY ACTIVATING SHOW OF FRAME
			;//TEST'S FOR MSE CALLED FROM LNOUT --
			;//THE SOURCE IS FNDMS.SR

.GTMES:	GTMES
.SVALO:	SVALO

GOTMSC:
	ZER 0,0		;//REFRESH SWITCHES
	STA 0,@.MTOKS
	STA 0,@.MCHRS
	STA 0,@.MWRDS
	STA 0,@.MSESW

	LDA 0,C4	;//AC0 _ 4=RETURN VEC'S LENGTH
	LDA 2,C2	;//AC2 _ 2=VEC WITH REF = 1
	JSRII .SVALO	;//ALLOCATE IT
	JSR @.SVLI	;//SET RETURN VAL -- NO REFI
	MOVZ 0,2	;//GET VEC PTR IN AC2
	LDA 0,@.RTNC	;//GET FIRST VALUE
			;//BYTEPTR (FOR CHAR OR WORD) OR TOKEN
			;//COUNT OR NOTFOUND VALUE (-1 OR -2)
	JSR @.SNST	;//CHUNK INTO VEC[1]
	2		;//2 BECAUSE 0=TYPE AND 1=LENGTH
	LDA 0,@.RTNX	;//GET RETURN X INTO AC0
	JSR @.SNST	;//CHUNK INTO VEC[2]
	3
	LDA 0,@.RTNW	;//GET RETURN WIDTH INTO ACO
	JSR @.SNST	;//CHUNK INTO VEC[3]
	4
	LDA 0,@.RTNY	;//GET RETURN Y IN AC0
	JSR @.SNST	;//CHUNK INTO VEC[4]
	5

	JMP @.ARET	;//ACTIVE RETURN

.END	
