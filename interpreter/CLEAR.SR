

;// FILE MAINTENANCE--      CLEAR.SR

;//THIS FILE CONTAINS THE "CLEARING" ROUTINES.
;//IT ALSO CONTAINS A UTIL (AT LBL INDEX)
;//WHICH TAKES AN X,W,Y,H TBL & COMPUTES A WORD ADDRESS OFFSET
;//FROM THE STRT OF THE BTMP ACCORDING TO Y AND X (RSLT IN AC0).
;//IT IS USED LOCALLY AND IS ALSO CALLED FROM SETXY AND BLKMV.

;//CLEARING IS ACCOMPLISHED WITH A COMBINATION OF BLOCK STORING
;//AND MASKING OPERATIONS.  IN ADDITION TO PASSING THE DIMENSIONS
;//OF THE DISPLAY RECTANGLE TO BE CLEARED, THERE IS ONE
;//ADDITIONAL ARGUMENT -- CLEARVALUE.  THE CLEARVALUE
;//IS THE PATTERN TO BE LAIN ON THE TARGET RECTANGLE -- A 
;//CLEARVALUE OF ZERO RESULTS IN A WHITE SCREEN, -1 IN A BLACK
;//SCREEN, ETC.
;//A CALL FROM SMALLTALK GETS PARAMETERS FROM ACTIVATION RECORD.
;//	to clear x width y height clearvalue 
;//	(:x.:width.:y.:height. :clearvalue.  CODE ??)
;//A CALL FROM ASM LANGUAGE LOOKS LIKE THIS:
;//	JSRII .CLER
;//	TABLE
;//	JMP CONT . . .
;//TABLE:
;//X:	0
;//WIDTH:	0
;//Y:	0
;//HEIGHT:	0
;//CLRVLU:	0

.TITL CLEAR
.GETNOLIST "SMALL.OPS"
.GETNOLIST "SMALL.SYMS"
.GETNOLIST "SMDISP.SYMS"

.SREL
CLEAR:	CLEARC
COMPL:	COMPLC
STCLR:	STCLRC
STCMP:	STCMPC
CLRX:	0
CLRWD:	0
CLRY:	0
CLRHT:	0
CLRVLU:	0
BITX:	0
BITWD:	0
BITY:	0
INDEX:	INDEXC
MKBLK:	MKBLKC


.NREL
-1
FOUR:	4
FIVE:	5
.INDEX:	INDEX		;//ADDRESSING PROBS
.MKBLK:	MKBLK

STCMPC:
	NIL 0,0		;//SET SWITCH FOR COMPLEMENTING
	STA 0,COMSW
	LDA 0,FOUR	;//ONLY NEED FOUR PARAMS
	STA 0,MSCNT
	JMP BOTH	;//GO TO COMMON CODE

STCLRC:
	LDA 0,FIVE	;//NEED FIVE PARAMS
	STA 0,MSCNT
BOTH:	JSRII .GTMS	;//GET ARGS--IF CALLED FROM SMALLTALK
MSCNT:	5		;//HERE FOR ADDRESSING REASONS
	CLRX
	JSR CLEARC	;//CALL MUTUAL CODE
	CLRX
	JMP @.EVAL

CLRTN:	0
.GTMS:	GTMES

COMPLC:
	NIL 0,0		;//THIS ASM LANG COMPLEMENT ENTRY
	STA 0,COMSW
CLEARC:
	STA 3,CLRTN	;//SAVE RETURN IF CALLED FROM ASM CODE
	LDA 0,0,3
	STA 0,BASTB	;//SAVE PTR TO TABLE
	LDA 3,0,3	;//SQUIRREL AWAY CLEARVALUE
	LDA 0,4,3
	STA 0,@.CLRVLU

	JSRII .INSC	;//INTERSECT SOURCE TABLE WITH DISPLAY
	DSPX
BASTB:	0
	CLRX		;//RSLT OF INSCTN USED AS BASIS FOR CLRNG
	JMP .RTRN	;//NO INTRSCTN SIMPLY RETURNS TO CALLER

	LDA 0,@.CLRY	;//MAKE BIT RECT'S Y RIGHT FOR SETXY
	STA 0,@.BITY

	ISZ LSWCH	;//SET SWTCH FOR LOOKING AT "LEFT" SIDE OF
 			;//RECTANGLE
	LDA 0,@.CLRHT	;//MAKE SCANLINE COUNTER
	STA 0,HTCNT
	LDA 0,@.CLRX	;//SAVE RIGHT BOUNDARY VALUE
	LDA 1,@.CLRWD
	ADDZ 0,1
	STA 1,RTBND
	STA 0,@.BITX	;//SAVE X FOR "LEFT" BIT CLEAR
	JSRII .MDIN	;//GET TO A WORD BOUNDARY
	STA 0,@.CLRX	;//SAVE X FOR WORD CLEAR
	LDA 2,@.BITX	;//IF BITX AND CLRX EQUAL THEN WE'RE ON
	SUBZ 2,0 SNR	;//WORD BOUNDARY
	JMP DOWRDS

	LDA 2,@.CLRWD	;//UPDATE REMAINING RECT WIDTH
	SLE 2,0		;//IF RECT IN ONE WORD THEN ONLY ONCE THRU
	JMP LFBITS
	STA 2,@.BITWD	;//CLRWD IS BITWID
	JSR CLRBTS	;//CLEAR THE BITS
	JMP .RTRN	;//AND GO HOME
LFBITS:
	STA 0,@.BITWD	;//OTHERWISE DIFFERENCE IS NO. OF BITS
			;//ON "LEFT" SIDE
	SUBZ 0,2
	STA 2,@.CLRWD
	JSR CLRBTS	;//AND GO CLEAR "LEFT" SIDE BITS

DOWRDS:
	LDA 0,@.CLRHT	;//REFRESH SCANLINE COUNTER
	STA 0,HTCNT
	LDA 0,@.CLRWD	;//MAKE BLOCKSIZE, I.E. NO. OF FULL WORDS
			;//PER SCAN LINE
	JSRII .MKBLK	;//4 MOVZR'S GOES FRM BTS 2 WRDS ALA NOVA
	SNZ 0,0		;//ZERO BLOCKSIZE MEANS NO FULL WORDS
	JMP RTBITS	;//SEE IS ANY "RIGHT" SIDE WORK	NEG 0,0
	STA 0,BLKSZ	;//SAVE BLOCK SIZE IN MINUS FORM

	JSRII .INDEX	;//COMPUTE DEST WORD ADDRESS
	CLRX		;//EXPECTS PTR TO X,W,Y,H TABLE	
	MOVZ 0,1	;//RESULT IN AC0
	LDA 0,@.CLRVLU	;//DATA TO BE STORED IS A CLEARVALUE

NXLIN:
	STA 1,WRDDWA	;//SAVE ACTUAL LEFT MARGIN
	LDA 3,BLKSZ	;//ADD BLK SIZE TO GET LAST WORD ADDRESS
			;//NEGATED SO IT RT FOR CALL ON BLOCKSTORE
	ADC 3,1		;//BLKS ACTUALLY WANTS DWA+(BLKSZ-1)
	LDA 2,COMSW	;//GET COMPLEMENT SWITCH IN AC2
	SP 2,2		;//NIL SWITCH MEANS COMPLEMENTING
	JMP BLKCM

	BLKS		;//CALL MICROCODE BLOCKSTORE
			;//IT WANTS NEGATIVE WORD COUNT IN AC3,
			;//LAST WORD ADDRESS IN AC1
			;//DATA TO BE STORED IN AC0
	JMP BMPLN

BLKCM:
	ADD 1,3		;//AC3 _ FIRST WORD - 1
	JMP CHKDN
COMPLP:
	LDA 0,0,3	;//GET DEST WORD
	COM 0,0
	STA 0,0,3	;//STORE IT BACK
CHKDN:
	INC 3,3		;//BUMP DWA
	SGT 3,1
	JMP COMPLP
BMPLN:

	LDA 2,@.DSPWD	;//GET DISPLAY WIDTH IN AC2 FOR BUMPING
			;//SCAN LINE
	LDA 1,WRDDWA	;//UPDATE SCAN LINE
	ADDZ 2,1
	DSZ HTCNT	;//DONE?
	JMP NXLIN

RTBITS:
	ZER 0,0		;//TURN OFF "LEFT" SWITCH
	STA 0,LSWCH	;//AND WORK ON "RIGHT" BITS
	LDA 0,@.CLRHT	;//RESET SCANLINE COUNTER
	STA 0,HTCNT
	LDA 0,@.CLRWD	;//IF CLRWD NOT MULTIPLE OF 16 THEN
	JSRII .MDDM	;//WORK
	LDA 1,@.CLRWD	;//LO ORDR BTS ARE NO. OF BTS TO BE CLRED
	SUBZ 0,1 SNR
	JMP .RTRN
	STA 1,@.BITWD	;//RT BND MINUS NO. OF BITS = BITX
	LDA 0,RTBND
	SUBZ 1,0
	STA 0,@.BITX
	JSR CLRBTS

.RTRN:
	ZER 3,3		;//REFRESH COMPL SWITCH
	STA 3,COMSW
	LDA 3,CLRTN	;//RETURN TO CALLER
	JMP 1,3


.CLRX:	CLRX		;//PLACE FOR X PARAMETER
.CLRWD:	CLRWD		;//PLACE FOR WIDTH PARAMETER
.CLRY:	CLRY		;//PLACE FOR Y PARAMETER
.CLRHT:	CLRHT		;//PLACE FOR HEIGHT PARAMETER
			;//CLEAR TABLE NOW IN SREL
.CLRVLU: CLRVLU
RTBND:	0

COMSW:	0
WRDDWA:	0
HTCNT:	0
LSWCH:	0
CLRMSK:	0
ORMSK:	0
SVMSK:	0
NUMSHF: 0
.BITX:	BITX
.BITWD:	BITWD
.BITY:	BITY
.DBA:	CTB1
.DWA:	CTB2
.STXY:	SETXY
.INSC:	INSEC
.MDIN:	MDINC
.MDDM:	MDDIM
.MSKS:	460
BLKSZ:	0		;//PLACE FOR SIZE OF CLEAR AREA
			;//IN WORDS

BTRTN:	0
CLRBTS:
	STA 3,BTRTN	;//BIT CLEARING SUBR

	JSRII .STXY	;//CHANGE X & Y INTO WORD AND BIT AD
	BITX

	LDA 2,.MSKS	;//GET MASK ADDRESS
	LDA 3,@.BITWD	;//NO. OF BITS IS INDEX INTO MASKS
	NEG 3,3		;//-1
	COM 3,3
	ADDZ 3,2
	LDA 0,0,2	;//GET IT
	STA 0,SVMSK	;//SAVE IT
	LDA 1,@.DBA	;//NO OF SHFTS = (DBA+1)-NO OF BITS(BITWD)
	INC 1,1
	INC 3,3		;//REAL BITWD
	SUBZ 3,1	;//NUMSHF IN AC1
	STA 1,NUMSHF

	LDA 3,LSWCH	;//IF ON LEFT SIDE THEN GRAB MASK VALUE
	SNZ 3,3		;//FROM RIGHT SIDE OF CLEARVALUE
	JMP SHFTMSK
	LDA 2,@.CLRVLU
	ANDZ 2,0
	CYCLE 0		;//SHIFT AND COMPLEMENT CLEAR VALUE
	COM 0,0		;//FOR OR'ING
	STA 0,ORMSK
SHFTMSK:
	LDA 0,SVMSK	;SHIFT CLEARING MASK
	LDA 1,NUMSHF
	CYCLE 0
	LDA 3,LSWCH
	SZE 3,3
	JMP DOBITS
	LDA 2,@.CLRVLU	;//WHEN ON "RIGHT" SIDE OF CLEAR VALUE
	ANDZ 0,2	;//GRAB MASK VALUE FROM "LEFT" SIDE OF
	COM 2,2		;//CLEARVALUE -- COMP FOR OR'ING
	STA 2,ORMSK

DOBITS:
	COM 0,0
	STA 0,CLRMSK
	LDA 3,@.DWA
	LDA 2,@.DSPWD

BITLOOP:
	ADDZ 2,3	;//ADD DISP WIDTH TO DWA -- STARTS OUT ONE
			;//LESS THAN ACTUAL STARTING SCAN LINE
	LDA 0,CLRMSK	;//GET CLEARING MASK	
	LDA 2,0,3	;//GET DEST WORD
	ANDZ 0,2	;//CLEAR BITS
	LDA 1,COMSW	;//SEE IF COMPLEMENTING
	SN 1,1
	JMP CLR
	LDA 1,0,3	;//GET ANOTHER COPY OF DEST WORD
	COM 0,0		;//IF COMP'NG COMP MASK
	ANDZ 0,1	;//GET DEST BITS
	COM 1,1		;//COMP THEM
	ANDZ 0,1	;//STRIP THE BITS OFF AGAIN
	COM 1,1		;//AND COM ONCE MORE
	SKIP
CLR:
	LDA 1,ORMSK	;//OR IN CLEARVALUE
			;//OR -- YOU'LL PARDON THE EXPRESSION --
			;//OR IN THE COMP'D BITS
	AND 1,2
	ADC 1,2
	STA 2,0,3	;//STORE FIXED BITS	LDA 2,@.DSPWD	;//GET DSPWD INTO AC2 FOR ADD AT LOOP TOP
	DSZ HTCNT	;//DEC SCANLINE COUNT
	JMP BITLOOP	;//LOOP

	JMP @BTRTN	;//RETURN



MKBLKC:
	MOVZR 0,0	;//FOR MAKING BLK SIZE FOR BLT AND BLK
	MOVZR 0,0	;//MICROINSTRUCTIONS
	MOVZR 0,0
	MOVZR 0,0
	JMP 0,3

.DSPWD:	DWDTH
.BTMP:	XYBITS		;//AD OF FIRST AD OF BIT MAP
.SVAC:	SVACS		;//AD OF SAVE AC1 AND AC2 ROUTINE
.RSAC:	RSACS		;//DITTO RESTORE
RTURN:	0
INDEXC:
	STA 3,RTURN	;//UTILITY FOR GETTING TO ADDRESS OFFSET
			;//FROM TOP LEFT CORNER OF DISPLAY
	JSRII .SVAC	;//SAVE THE AC'S
	LDA 3,@RTURN	;//GET PTR TO TABLE
	LDA 1,2,3	;//GET Y FROM TABLE
	LDA 2,@.DSPWD	;//GET WIDTH OF DISPLAY
	ZER 0,0		;//FIX AC0 FOR MUL COMPATIBILITY
	JSR @.MUL	;//WDTH * Y IS HOW MUCH TO ADD TO BASE
	LDA 2,@.BTMP	;//GET BASE
	ADDZ 1,2	;//GETS TO CORRECT Y OF LFT OF DISP
	LDA 3,@RTURN
	LDA 0,0,3	;//NOW INDEX IN X DIRECTION
	MOVZ 0,1	;//NEG X ?(MAKE POS)
	SP 1,1
	NEG 0,0
	JSR MKBLKC	;//4 MOVZR'S MAKE WORD VALUE
	SP 1,1		;//MAKE NEG AGAIN IS NECESSARY
	NEG 0,0
	ADDZ 2,0	;//ADD TO LFT MRGN AND RSLT RTRND IN AC0
	JSRII .RSAC	;//MAKE AC1 AND AC2 LOOK RIGHT
	LDA 3,RTURN
	JMP 1,3

 
.END
	D