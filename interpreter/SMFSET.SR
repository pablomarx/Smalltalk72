;//	SMFSET.SR
;//	SET PAGE/BYTE POINTER IN FILES, READ/WRITE CHAIN OF
;//	DISK PAGES.

	.TITL	SMFSET

	.GETNOLIST	"SMALL.OPS"
	.GETNOLIST	"SMALL.SYMS"
	.GETNOLIST	"SMFILES.OPS"
	.GETNOLIST	"SMFILES.SYMS"

	.SREL

SREW:	SREWC
SREOF:	SREOFC
SFLUSH:	SFLUSC
SRBYTE:	SRBYTC
SWBYTE:	SWBYTC
DSKRW:	DSKRWC

		.NREL

	VSAV	=IMAX-4+5	;// SAVE INTEGERS FOR DISK# AND
			;// LABEL (OMITTING LEADER, CURADR, BYTEC,
			;// DIRTY) BUT ADDING S3,RW,FINST,PB,SSADR
FLUSH:	0
LARGE:	37777
.GBDK:	GBDSK
C777:	777
.IRCOP:	IRCOP
	
;//	ROUTINES TO SET TO AN ABSOLUTE POSITION IN A FILE
;//	BY BYTE AND PAGE, IN EITHER READ OR WRITE MODE.
;//	 AC0 IS BYTE COUNT
;//	 AC1 IS PAGE NUMBER
;//	 AC2 IS FILE INSTANCE
;//	RETURNS+1 IF ERROR OR EOF (AC0=0)
;//	RETURNS+2 IF OK, AC0=NUMCH, AC1=BYTEC
	
SREWC:	ONE	1,1,SKP	;// PAGE 1
SREOFC:	 LDA	1,LARGE	;// SET TO EOF. MORE PAGES THAN ON DISK
	ZER	0,0	;// BEGINNING OF PAGE
	STA	3,S3
	JMP	WIFD
SFLUSC:	STA	3,S3	;// FLUSH
	JSR	@.LNST	;// CURRENT PAGE
	PAGEN
	STA	0,PN
	JSR	@.LNST	;// CURRENT BYTE COUNT
	BYTEC
	LDA	1,PN
	JMP	WIFD
	 
SRBYTC:	STA	3,S3
	ONE	3,3,SKP	;// DON'T WRITE IF NO PAGE CHANGE
WIFD:	 NIL	3,3	;// WRITE IF DIRT, EVEN IF NO PAGE CHANGE
	STA	3,FLUSH
	NIL	3,3	;// DON'T WRITE AFTER EOF (READ ONLY)
	JMP	RONLY

SWBYTC:	STA	3,S3
	ONE	3,3	;// DON'T WRITE IF NO PAGE CHANGE. WRITE
	STA	3,FLUSH	;// AFTER EOF.
RONLY:	STA	3,RW
	STA	2,FINST
	STA	1,PN
	STA	0,PB
	 
	JSRII	.IRCOP	;// COPY INSTANCE IN AC2
	SN2		;// LEADER THRU SN2
	1+SN2+IT-.
	-IMAX
			;// AC2 STILL WITH FILE INSTANCE
	JSRII	.GBDK	;// GET/SET BITTABLE AND DISK NUMBER
	STA	0,DISK+IT	;// DISK NUMBER PRECEDES LABEL
	LDA	2,FINST
	LDA	1,C3
	ADD	2,1
	LOAD		;// STRING BUFFER INSTANCE -- SADR
	INC	0,0
	INC	0,0
	STA	0,SSADR		;// SAVE FOR BSCOP, SBCOP
	 
;//	FOLLOWING MESSY CODE JUGGLES PN,PB TO LIE WITHIN A PAGE
;//	ASSUMES PAGES ARE FULL (NUMCH='1000) EXCEPT LAST
;//	X,Y --> X + Y DIV 512, Y MOD 512
;//	IF PN NEQ -1, X,0 MAY BE CHANGED TO X-1,512
 
	LDA	0,PB
	MOV	0,2	;// SAVE FOR SIGN TEST
	SP	2,2
	 NEG	0,0	;// -PB
	LDA	3,LBMSK	;// DIV '1000 TO GET PAGE NUMBER
	ANDS	0,3
	MOVZR	3,3
	SP	2,2	;// PB>=0?
	 NEG	3,3	;// -PAGE NUMBER
	LDA	1,PN
	SP	1,1
	 LDA	1,PAGEN+IT	;// NEGATIVE GETS CURRENT PAGE
	ADD	1,3
	LDA	1,C777	;// MOD '1000 TO GET BYTE COUNT
	AND	1,0,SZR	;// FOR 0 BYTE COUNT,DON'T CHECK NEGATIVE PB
	 SN	2,2	;// PB<0?
	  JMP	.+3
	NEG	0,0	;// 0 > BC > -1000
	JMP	SBP	;// BACKUP A PAGE
 
	LDA	1,PN
	SP	1,1	;// PN = -1?
	 JMP	CDONE
	SZE	2,2	;// PB ZERO TO START WITH?
	 SZE	0,0	;// ZERO NOW?
	  JMP	CDONE
 
SBP:	NEG	3,3	;// BACK UP ONE PAGE
	COM	3,3
	LDA	1,C1000
	ADD	1,0
CDONE:	STA	3,PN		;// DESTINATION PAGE
	STA	0,PB		;// DESTINATION BYTE
	LDA	0,PAGEN+IT	;// CURRENT PAGE
	SUB	0,3
	STA	3,PDIFF	;// NUMBER OF PAGES TO MOVE

	LDA	1,DIRTY+IT	;// CURRENT PAGE DIRTY?
	SNZ	1,1
	 JMP	.READ
	SNZ	3,3	;// MOVE TO ANOTHER PAGE?
	 JMP	WZER
	LDA	0,NEXTP+IT
	SN	3,3	;// BACKWARDS...
	 SZE	0,0	;// OR FORWARDS WITH EXISTING NEXTP IS OK
	  JMP	WTHIS
	JMP	WALOC	;// WRITE AND ALLOCATE MORE PAGES (IN AC3)?

WZER:	ISZ	FLUSH	;// FORCE WRITE IF PDIFF=0?
	 JMP	RRDN	;// DONE, BUT DON'T CHANGE "DIRTY"
WTHIS:	LDA	2,SSADR
	JSRII	.SBCOP		;// COPY SMALLTALK STRING TO BUFFER
				;// AC0 HAS BUFFER CORE ADDRESS
	LDA	1,CURADR+IT
	LDA	2,.CCW
	ISZ	DIRTY+IT	;// WRITE DATA ONLY?
	 LDA	2,.CWW		;// WRITE LABEL BLOCK TOO
	LDA	3,PAGEN+IT
	STA	3,WSPGS
	JSRII	.DSKIO
	DISK+IT-.
WSPGS:	0		;// STARTING PAGE
	1		;// WRITE ONE PAGE
.DBUF:	DSKBUF		;// IRRELEVANT
	 JMP	DDERR
	LDA	3,PDIFF

.READ:	SNZ	3,3	;// ANY PAGES TO READ?
	 JMP	RDONE
	LDA	0,C4
	LDA	1,FINST
	ADD	0,1
	LOAD		;// RANDOM ACCESS VECTOR
	INC	0,1,SNR	;// NIL?
	 JMP	RCHAIN
	LOAD		;// LENGTH
	JMP	.RAND
RRDN:	JMP	RDN1	;// ADDRESS PROBLEM

ITAB:	.BLK	IMAX	;// INSTANCE INTEGER TABLE

IT	= ITAB-IBEG	;// INCOMPLETE INSTANCE OFFSETTING
S3:	0	;// RETURN ADR &4 MORE VARIABLES TO BE SAVED
RW:	0	;// -1 MEANS READ ONLY
FINST:	0	;// FILE INSTANCE
PB:	0	;// DESTINATION BYTE COUNT
SSADR:	0	;// SMALLTALK STRING ADDRESS

PN:	0	;// DESTINATION PAGE NUMBER
PDIFF:	0	;// NUMBER OF PAGES TO SKIP

.RAND:	LDA	2,PN
	SLEZ	2,2	;// 0 < PN <= RVEC LENGTH?
	 SLE	2,0
	  JMP	RCHAIN
	ADD	2,1
	LOAD		;// RVEC[PN]
	SNN	0,0	;// NIL?
	 JMP	RCHAIN
	JSR	@.IVAL	;// ASSUME INTEGER
	MOV	0,1	;// DISK ADDRESS
	LDA	0,PN
	JMP	ONEP
RCHAIN:	LDA	0,PAGEN+IT
	LDA	3,PDIFF
	SGZ	3,3
	 JMP	RNEG
	LDA	1,NEXTP+IT	;// FORWARD
	SNZ	1,1
	 JMP	WALOC
	INC	0,0		;// CHECK PAGE NUMBER
	JMP	RTHIS

RLDR:	INC	0,3	;// READ LEADER...UPTO DESTINATION PAGE
	LDA	1,LEADER+IT
	ZER	0,0	;// CHECK.
	JMP	RTHIS
RNEG:	LDA	0,PN		;// DESTINATION PAGE
	SZE	0,0		;// IF PAGE 0 OR
	 SNL	3,3		;// MORE THAN 1 PAGE BACKWARDS
	  JMP	RLDR		;// ...READ LEADER
	LDA	1,BACKP+IT
ONEP:	ONE	3,3	;// READ ONE PAGE, CHECK DESTINATION IN AC0
RTHIS:	STA	3,RPAGE
	STA	0,SPAGE
	LDA	0,@.DBUF	;// DISK BUFFER
	LDA	2,.CCR
	JSRII	.DSKIO	;// AC2 STILL HAS COMMAND
	DISK+IT-.
SPAGE:	0		;// STARTING PAGE NUMBER
RPAGE:	0		;// NUMBER OF PAGES
	0		;// WRITE TO SAME BUFFER
	 NEG	0,0,SKP	;// ERROR
	  JMP	.+4	;// SUCCESS
	LDA	3,RPAGE
	ADD	0,3,SNR	;// IF NO PAGES READ, AC1 IS NOT CURADR
DDERR:	 JMP	DERR
	STA	1,CURADR+IT
	STA	0,PDIFF	;// - IF ERROR.

	LDA	2,SSADR
	JSRII	.BSCOP	;// COPY BUFFER INTO SMALLTALK STRING
	LDA	3,PDIFF	;// PAGES LEFT?
	SNZ	3,3
	 JMP	RDONE
	SP	3,3	;// DISK ERROR?
	 JMP	DERR
	JMP	WALOC

C1000:	1000
.SBCOP:	SBCOP
.CCR:	CCR
.CCW:	CCW
.CWW:	CWW

WALOC:	LDA	0,RW	;// IF NEXTP NOT 0, CAUGHT BY WDSKO
	SP	0,0	;// READ ONLY
	 JMP	REOF
	STA	3,WPAGE		;// NUMBER OF PAGES
	JSRII	.BLT	;// SAVE INSTANCE AND VARS
	0+DISK+IT-1-.
	1+SAV+VSAV-1-.
	-VSAV
 
	NIL	0,0		;// CALL GDATA AFTER ALLOCATION
	LDA	1,CURADR+IT
	JSR	WDSKO		;// WRITE A CHAIN OF NEW PAGES
	SAV-.		;// DO I/O ACCORDING TO SAVED LABEL
.DSKIO:	DSKIO		;// IGNORED
WPAGE:	0
	0		;// CORE INCREMENT=0
	 NIL	0,0		;// SAVE ERROR
	STA	0,PDIFF
	STA	1,CURADR+IT	;// DOESN'T GET COPIED OVER

	JSRII	.BLT
	0+SAV-1-.
	1+DISK+IT+VSAV-1-.
	-VSAV

	ISZ	PDIFF	;// DISK ERROR?
RDONE:	 ZER	0,0,SKP	;// OK
	JMP	DERR
	STA	0,DIRTY+IT	
RDN1:	LDA	0,NUMCH+IT	;// FIXUP BYTEC, MAYBE NUMCH
	LDA	1,PB
	ZER	2,2	;// FOR STATUS
	LDA	3,NEXTP+IT
	SNZ	3,3	;// IS THERE A NEXT PAGE?
	 SGE	1,0	;// PB>= NUMCH?
	  JMP	RB	;// BYTEC _ PB (NORMAL CASE)
	ISZ	RW	;// READ ONLY?
	 JMP	RNB	;// NUMCH _ BYTEC _ PB
				;// ENTRY PT FOR EOF
REOF:	LDA	1,NUMCH+IT	;// BYTEC _ NUMCH
	NIL	2,2,SKP	;// EOF (ASSUMING PAGES ARE FULL)
RNB:	 SNE	1,0	;// IF NUMCH IS ALREADY PB, DON'T DIRTY
	  JMP	RB
	ONE	3,3
	STA	3,DIRTY+IT
	STA	1,NUMCH+IT
RB:	STA	1,BYTEC+IT
DERR:	STA	2,STATUS+IT	;// IF DISK ERR, AC2 HAS DCB PTR

	LDA	2,FINST	;// COPY TABLE BACK TO INSTANCE
	JSRII	.RICOP
	SN2		;// CURADR THRU SN2
	1+SN2+IT-.
	-IMAX+1

	ZER	0,0
	LDA	1,BYTEC+IT
	LDA	3,STATUS+IT
	SZE	3,3	;// NULL CHAR IF EOF OR ERROR
	 JMP	@S3
	LDA	0,NUMCH+IT	;// OF INTEREST TO GFCH, PFCH
	LDA	3,S3
	JMP	1,3	;// SUCCESSFUL!
 
.BSCOP:	BSCOP
.RICOP:	RICOP
.BLT:	BLTT

;// WRITE CHAIN OF NEW PAGES (ENTRY POINT)
;// AC0 CORE, AC1 DISK ADR

WDSKO:	STA	3,W3
	STA	0,DCOR
	LDA	2,0,3	;// LABEL PTR-1
	ADD	3,2	;// MAKE ABSOLUTE
	LDA	0,NEXTP-DISK,2

	LDA	2,2,3	;// NUMBER OF PAGES
	SNZ	0,0	;// SHOULD BE AT END OF CHAIN
	 SGZ	2,2
	  JMP	DARGS,3
	STA	2,WPGS

RWENT:	STA	1,DCUR		;// ENTER HERE FROM DSKRW
	LDA	0,3,3		;// CORE INC
	STA	0,WCORE
	LDA	2,0,3		;// LABEL PTR-1, OFFSET
	ADD	3,2		;// ABSOLUTE
	STA	2,ALAB		;// ABSOLUTE LABEL PTR
	JSR	@.PNT		;// AFFECTS ONLY AC0,AC3
	WLAB-.
	SUB	0,2		;// AC0 HAS WLAB'S ABSOLUTE ADR
	STA	2,WLAB		;// LABEL PTR RELATIVE AGAIN

WNEXT:	JSRII	.ALLOC	;// ALLOCATE NEXT PAGE. AC1 HAS CURRENT ADR
	 JMP	WERR
	LDA	3,ALAB
	STA	1,NEXTP-DISK,3	;// NEW NEXT POINTER INTO LABEL
	LDA	0,C1000
	STA	0,NUMCH-DISK,3	;// MAKE SURE PAGE IS FULL

WWRIT:	LDA	0,DCOR
	SNL	0,0
	 JMP	WBUF
	LDA	2,SAV+VSAV-1	;// SAVED STRING ADDRESS
	JSRII	.SBCOP
WBUF:	LDA	1,DCUR
	LDA	2,.CWW	;// WRITE LABEL, DATA
	JSRII	.DSKIO
WLAB:	0
.ALLOC:	ALLOC		;// IRRELEVANT
	1		;// ONE PAGE AT A TIME
WCORE:	0
	 JMP	WERR

	LDA	0,DCBDAT,2
	LDA	3,WCORE
	ADD	3,0
	STA	0,DCOR	;// NEXT CORE ADDRESS

	LDA	3,ALAB
	LDA	0,NEXTP-DISK,3
	SNZ	0,0
	 JMP	WRET		;// STOP BY WRITING LAST PAGE
				;// WITH NEXTP=NUMCH=0, AC0=0
	ISZ	PAGEN-DISK,3	;// PAGEN_PAGEN+1
	STA	1,BACKP-DISK,3	;// BACKP_CURADR
	LDA	1,NEXTP-DISK,3
	STA	1,DCUR
	ZER	0,0
	STA	0,NEXTP-DISK,3
	STA	0,LNUSED-DISK,3
	STA	0,NUMCH-DISK,3	;// EMPTY PAGE FOR LAST???
	DSZ	WPGS
	 JMP	WNEXT		;// GET NONZERO NEXTP
	JMP	WWRIT		;// WRITE CURRENT PAGE, THEN STOP
WRET:	ISZ	W3		;// SUCCESSFUL RETURN
WERR:	LDA	3,W3
	JMP	DARGS,3

;//	READ/WRITE DISK PAGES...IF WRITING, IT CONTINUES AFTER EOF
;//	 AC0 CORE ADDRESS, AC1 DISK ADDRESS, AC2 COMMAND

DSKRWC:	STA	3,W3
	STA	2,DCUR	;// COMMAND
	STA	0,DCOR	;// CORE ADR
	LDA	2,1,3
	STA	2,RWSPG
	LDA	2,2,3
	STA	2,RWNPG
	LDA	2,3,3
	STA	2,RWCOR

	LDA	2,0,3	;// LABEL PTR-1, OFFSET
	ADD	3,2	;// ABSOLUTE
	JSR	@.PNT	;// AFFECTS AC0,AC3
	RWLAB-.
	SUB	0,2	;// LABEL PTR RELATIVE AGAIN
	STA	2,RWLAB
	LDA	0,DCOR
	LDA	2,DCUR
	JSRII	.DSK0	;// ALLOW ZERO ADDRESS
RWLAB:	0
RWSPG:	0
RWNPG:	0
RWCOR:	0
	 JMP	WERR
	SNZ	0,0	;// PAGES LEFT
	 JMP	WRET
	STA	0,WPGS
	LDA	0,DCBCOM,2	;// WAS COMMAND WRITING DATA?
	LDA	3,C10
	AND	0,3,SNR
	 JMP	WERR
	LDA	0,DCBDAT,2	;// LAST CORE ADR
	STA	0,DCOR		;// SAVE
	LDA	3,W3
	JMP	RWENT		;// WDSKO CONTINUES

ALAB	=RWLAB		;// NOT USED AT SAME TIME
.DSK0:	DSK0
WPGS:	0
W3:	0
DCUR:	0
DCOR:	0
C10:	10
SAV:	.BLK	VSAV	;// SAVE AREA

	.ENDE